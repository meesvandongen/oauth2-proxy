{"config":{"lang":["en"],"separator":"[\\s\\-|]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>A reverse proxy and static file server that provides authentication using Providers (Google, GitHub, and others) to validate accounts by email, domain or group.</p> <p>Note</p> <p>This repository was forked from bitly/OAuth2_Proxy on 27/11/2018. Versions v3.0.0 and up are from this fork and will have diverged from any changes in the original fork. A list of changes can be seen in the CHANGELOG.</p> <p></p>"},{"location":"#architecture","title":"Architecture","text":""},{"location":"behaviour/","title":"Behaviour","text":"<ol> <li>Any request passing through the proxy (and not matched by <code>--skip-auth-regex</code>) is checked for the proxy's session cookie (<code>--cookie-name</code>) (or, if allowed, a JWT token - see <code>--skip-jwt-bearer-tokens</code>).</li> <li>If authentication is required but missing then the user is asked to log in and redirected to the authentication provider (unless it is an Ajax request, i.e. one with <code>Accept: application/json</code>, in which case 401 Unauthorized is returned)</li> <li>After returning from the authentication provider, the oauth tokens are stored in the configured session store (cookie, redis, ...) and a cookie is set</li> <li>The request is forwarded to the upstream server with added user info and authentication headers (depending on the configuration)</li> </ol> <p>Notice that the proxy also provides a number of useful endpoints.</p>"},{"location":"installation/","title":"Installation","text":"<ol> <li> <p>Choose how to deploy:</p> <p>a. Using a Prebuilt Binary (current release is <code>v7.6.0</code>)</p> <p>b. Using Go to install the latest release <pre><code>$ go install github.com/oauth2-proxy/oauth2-proxy/v7@latest\n</code></pre> This will install the binary into <code>$GOPATH/bin</code>. Make sure you include <code>$GOPATH</code> in your <code>$PATH</code>. Otherwise your system won't find binaries installed via <code>go install</code></p> <p>c. Using a Prebuilt Docker Image (AMD64, PPC64LE, ARMv6, ARMv7, and ARM64 available)</p> <p>d. Using a Pre-Release Nightly Docker Image (AMD64, PPC64LE, ARMv6, ARMv7, and ARM64 available)</p> <p>e. Using the official Kubernetes manifest (Helm)</p> <p>Prebuilt binaries can be validated by extracting the file and verifying it against the <code>sha256sum.txt</code> checksum file provided for each release starting with version <code>v3.0.0</code>.</p> <pre><code>$ sha256sum -c sha256sum.txt\noauth2-proxy-x.y.z.linux-amd64: OK\n</code></pre> </li> <li> <p>Select a Provider and Register an OAuth Application with a Provider</p> </li> <li>Configure OAuth2 Proxy using config file, command line options, or environment variables</li> <li>Configure SSL or Deploy behind an SSL endpoint (example provided for Nginx)</li> </ol>"},{"location":"welcome/","title":"Welcome","text":"<p>A reverse proxy and static file server that provides authentication using Providers (Google, GitHub, and others) to validate accounts by email, domain or group.</p> <p>Note</p> <p>This repository was forked from bitly/OAuth2_Proxy on 27/11/2018. Versions v3.0.0 and up are from this fork and will have diverged from any changes in the original fork. A list of changes can be seen in the CHANGELOG.</p> <p></p>"},{"location":"welcome/#architecture","title":"Architecture","text":""},{"location":"community/contribution/","title":"Contribution Guide","text":"<p>We track bugs and issues using Github.</p> <p>If you find a bug, please open an Issue. When opening an Issue or Pull Request please follow the preconfigured template and take special note of the checkboxes.</p> <p>If you want to fix a bug, add a new feature or extend existing functionality, please create a fork, create a feature branch and open a PR back to this repo. Please mention open bug issue number(s) within your PR if applicable.</p> <p>We suggest using Visual Studio Code with the official Go for Visual Studio Code extension.</p>"},{"location":"community/contribution/#go-version","title":"Go version","text":"<p>This project is currently still using go 1.19. You can follow the installation guide for go here. And you can find go version 1.19 in the archived section here.</p>"},{"location":"community/contribution/#preparing-your-fork","title":"Preparing your fork","text":"<p>Clone your fork, create a feature branch and update the depedencies to get started. <pre><code>git clone git@github.com:&lt;YOUR_FORK&gt;/oauth2-proxy\ncd oauth2-proxy\ngit branch feature/&lt;BRANCH_NAME&gt;\ngit push --set-upstream origin feature/&lt;BRANCH_NAME&gt;\ngo mod download\n</code></pre></p>"},{"location":"community/contribution/#testing-debugging","title":"Testing / Debugging","text":"<p>For starting oauth2-proxy locally open the debugging tab and create the <code>launch.json</code> and select <code>Go: Launch Package</code>.</p> <p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Launch OAuth2-Proxy with Dex\",\n            \"type\": \"go\",\n            \"request\": \"launch\",\n            \"mode\": \"auto\",\n            \"program\": \"${workspaceFolder}\",\n            \"args\": [\n                \"--config\",\n                // The following configuration contains settings for a locally deployed \n                // upstream and dex as an idetity provider\n                \"contrib/local-environment/oauth2-proxy.cfg\"\n            ]\n        },\n        {\n            \"name\": \"Launch OAuth2-Proxy with Keycloak\",\n            \"type\": \"go\",\n            \"request\": \"launch\",\n            \"mode\": \"auto\",\n            \"program\": \"${workspaceFolder}\",\n            \"args\": [\n                \"--config\",\n                // The following configuration contains settings for a locally deployed \n                // upstream and keycloak as an idetity provider\n                \"contrib/local-environment/oauth2-proxy-keycloak.cfg\"\n            ]\n        }\n    ]\n}\n</code></pre></p> <p>Before you can start your local version of oauth2-proxy, you will have to use the provided docker compose files to start a local upstream service and identity provider. We suggest using httpbin as your upstream for testing as it allows for request and response introspection of all things HTTP.</p> <p>Open a terminal and switch to the <code>contrib/local-environment</code> directory.</p> <ul> <li>Dex as your IdP: <code>docker compose -f docker-compose.yaml up dex etcd httpbin</code></li> <li>Keycloak as your IdP: <code>docker compose -f docker-compose-keycloak.yaml up keycloak httpbin</code></li> </ul> <p>The username for both is <code>admin@example.com</code> and password is <code>password</code>.</p> <p>Start oauth2-proxy from the debug tab and open http://oauth2-proxy.localtest.me:4180/ for testing.</p>"},{"location":"community/security/","title":"Security","text":"<p>Note</p> <p>OAuth2 Proxy is a community project. Maintainers do not work on this project full time, and as such, while we endeavour to respond to disclosures as quickly as possible, this may take longer than in projects with corporate sponsorship.</p>"},{"location":"community/security/#security-disclosures","title":"Security Disclosures","text":"<p>Important</p> <p>If you believe you have found a vulnerability within OAuth2 Proxy or any of its dependencies, please do NOT open an issue or PR on GitHub, please do NOT post any details publicly.</p> <p>Security disclosures MUST be done in private. If you have found an issue that you would like to bring to the attention of the maintenance team for OAuth2 Proxy, please compose an email and send it to the list of maintainers in our MAINTAINERS file.</p> <p>Please include as much detail as possible. Ideally, your disclosure should include: - A reproducible case that can be used to demonstrate the exploit - How you discovered this vulnerability - A potential fix for the issue (if you have thought of one) - Versions affected (if not present in master) - Your GitHub ID</p>"},{"location":"community/security/#how-will-we-respond-to-disclosures","title":"How will we respond to disclosures?","text":"<p>We use GitHub Security Advisories to privately discuss fixes for disclosed vulnerabilities. If you include a GitHub ID with your disclosure we will add you as a collaborator for the advisory so that you can join the discussion and validate any fixes we may propose.</p> <p>For minor issues and previously disclosed vulnerabilities (typically for dependencies), we may use regular PRs for fixes and forego the security advisory.</p> <p>Once a fix has been agreed upon, we will merge the fix and create a new release. If we have multiple security issues in flight simultaneously, we may delay merging fixes until all patches are ready. We may also backport the fix to previous releases, but this will be at the discretion of the maintainers.</p>"},{"location":"configuration/alpha_config/","title":"Alpha Configuration","text":"<p>Warning</p> <p>This page contains documentation for alpha features. We reserve the right to make breaking changes to the features detailed within this page with no notice.</p> <p>Options described in this page may be changed, removed, renamed or moved without prior warning. Please beware of this before you use alpha configuration options.</p> <p>This page details a set of alpha configuration options in a new format. Going forward we are intending to add structured configuration in YAML format to replace the existing TOML based configuration file and flags.</p> <p>Below is a reference for the structure of the configuration, with AlphaOptions as the root of the configuration.</p> <p>When using alpha configuration, your config file will look something like below:</p> <pre><code>upstreams:\n  - id: ...\n    ...: ...\ninjectRequestHeaders:\n  - name: ...\n    ...: ...\ninjectResponseHeaders:\n  - name: ...\n    ...: ...\n</code></pre> <p>Please browse the reference below for the structure of the new configuration format.</p>"},{"location":"configuration/alpha_config/#using-alpha-configuration","title":"Using Alpha Configuration","text":"<p>To use the new alpha configuration, generate a YAML file based on the format described in the reference below.</p> <p>Provide the path to this file using the <code>--alpha-config</code> flag.</p> <p>Note</p> <p>When using the <code>--alpha-config</code> flag, some options are no longer available. See removed options below for more information.</p>"},{"location":"configuration/alpha_config/#converting-configuration-to-the-new-structure","title":"Converting configuration to the new structure","text":"<p>Before adding the new <code>--alpha-config</code> option, start OAuth2 Proxy using the <code>convert-config-to-alpha</code> flag to convert existing configuration to the new format.</p> <pre><code>oauth2-proxy --convert-config-to-alpha --config ./path/to/existing/config.cfg\n</code></pre> <p>This will convert any options supported by the new format to YAML and print the new configuration to <code>STDOUT</code>.</p> <p>Copy this to a new file, remove any options from your existing configuration noted in removed options and then start OAuth2 Proxy using the new config.</p> <pre><code>oauth2-proxy --alpha-config ./path/to/new/config.yaml --config ./path/to/existing/config.cfg\n</code></pre>"},{"location":"configuration/alpha_config/#using-env-variables-in-the-alpha-configuration","title":"Using ENV variables in the alpha configuration","text":"<p>The alpha package supports the use of environment variables in place of yaml keys, allowing sensitive values to be pulled from somewhere other than the yaml file. When using environment variables, your yaml will look like this:</p> <p><pre><code>    providers:\n    - provider: azure\n      clientSecret: ${CLIENT_SECRET}\n      ...\n</code></pre> Where CLIENT_SECRET is an environment variable. More information and available patterns can be found here</p>"},{"location":"configuration/alpha_config/#removed-options","title":"Removed options","text":"<p>The following flags/options and their respective environment variables are no longer available when using alpha configuration:</p> <ul> <li><code>flush-interval</code>/<code>flush_interval</code></li> <li><code>pass-host-header</code>/<code>pass_host_header</code></li> <li><code>proxy-websockets</code>/<code>proxy_websockets</code></li> <li><code>ssl-upstream-insecure-skip-verify</code>/<code>ssl_upstream_insecure_skip_verify</code></li> <li><code>upstream</code>/<code>upstreams</code></li> </ul> <ul> <li><code>pass-basic-auth</code>/<code>pass_basic_auth</code></li> <li><code>pass-access-token</code>/<code>pass_access_token</code></li> <li><code>pass-user-headers</code>/<code>pass_user_headers</code></li> <li><code>pass-authorization-header</code>/<code>pass_authorization_header</code></li> <li><code>set-basic-auth</code>/<code>set_basic_auth</code></li> <li><code>set-xauthrequest</code>/<code>set_xauthrequest</code></li> <li><code>set-authorization-header</code>/<code>set_authorization_header</code></li> <li><code>prefer-email-to-user</code>/<code>prefer_email_to_user</code></li> <li><code>basic-auth-password</code>/<code>basic_auth_password</code></li> <li><code>skip-auth-strip-headers</code>/<code>skip_auth_strip_headers</code></li> </ul> <ul> <li><code>client-id</code>/<code>client_id</code></li> <li><code>client-secret</code>/<code>client_secret</code>, and <code>client-secret-file</code>/<code>client_secret_file</code></li> <li><code>provider</code></li> <li><code>provider-display-name</code>/<code>provider_display_name</code></li> <li><code>provider-ca-file</code>/<code>provider_ca_files</code></li> <li><code>login-url</code>/<code>login_url</code></li> <li><code>redeem-url</code>/<code>redeem_url</code></li> <li><code>profile-url</code>/<code>profile_url</code></li> <li><code>resource</code></li> <li><code>validate-url</code>/<code>validate_url</code></li> <li><code>scope</code></li> <li><code>prompt</code></li> <li><code>approval-prompt</code>/<code>approval_prompt</code></li> <li><code>acr-values</code>/<code>acr_values</code></li> <li><code>user-id-claim</code>/<code>user_id_claim</code></li> <li><code>allowed-group</code>/<code>allowed_groups</code></li> <li><code>allowed-role</code>/<code>allowed_roles</code></li> <li><code>jwt-key</code>/<code>jwt_key</code></li> <li><code>jwt-key-file</code>/<code>jwt_key_file</code></li> <li><code>pubjwk-url</code>/<code>pubjwk_url</code></li> </ul> <p>and all provider-specific options, i.e. any option whose name includes <code>oidc</code>, <code>azure</code>, <code>bitbucket</code>, <code>github</code>, <code>gitlab</code>, <code>google</code> or <code>keycloak</code>.  Attempting to use any of these options via flags or via config when <code>--alpha-config</code> is set will result in an error.</p> <p>Important</p> <p>You must remove these options before starting OAuth2 Proxy with <code>--alpha-config</code></p>"},{"location":"configuration/alpha_config/#configuration-reference","title":"Configuration Reference","text":""},{"location":"configuration/alpha_config/#adfsoptions","title":"ADFSOptions","text":"<p>(Appears on: Provider)</p> Field Type Description <code>skipScope</code> bool Skip adding the scope parameter in login requestDefault value is 'false'"},{"location":"configuration/alpha_config/#alphaoptions","title":"AlphaOptions","text":"<p>AlphaOptions contains alpha structured configuration options. Usage of these options allows users to access alpha features that are not available as part of the primary configuration structure for OAuth2 Proxy.</p> <p>Warning</p> <p>The options within this structure are considered alpha. They may change between releases without notice.</p> Field Type Description <code>upstreamConfig</code> UpstreamConfig UpstreamConfig is used to configure upstream servers.Once a user is authenticated, requests to the server will be proxied tothese upstream servers based on the path mappings defined in this list. <code>injectRequestHeaders</code> []Header InjectRequestHeaders is used to configure headers that should be addedto requests to upstream servers.Headers may source values from either the authenticated user's sessionor from a static secret value. <code>injectResponseHeaders</code> []Header InjectResponseHeaders is used to configure headers that should be addedto responses from the proxy.This is typically used when using the proxy as an external authenticationprovider in conjunction with another proxy such as NGINX and itsauth_request module.Headers may source values from either the authenticated user's sessionor from a static secret value. <code>server</code> Server Server is used to configure the HTTP(S) server for the proxy application.You may choose to run both HTTP and HTTPS servers simultaneously.This can be done by setting the BindAddress and the SecureBindAddress simultaneously.To use the secure server you must configure a TLS certificate and key. <code>metricsServer</code> Server MetricsServer is used to configure the HTTP(S) server for metrics.You may choose to run both HTTP and HTTPS servers simultaneously.This can be done by setting the BindAddress and the SecureBindAddress simultaneously.To use the secure server you must configure a TLS certificate and key. <code>providers</code> Providers Providers is used to configure multiple providers."},{"location":"configuration/alpha_config/#azureoptions","title":"AzureOptions","text":"<p>(Appears on: Provider)</p> Field Type Description <code>tenant</code> string Tenant directs to a tenant-specific or common (tenant-independent) endpointDefault value is 'common' <code>graphGroupField</code> string GraphGroupField configures the group field to be used when building the groups list from Microsoft GraphDefault value is 'id'"},{"location":"configuration/alpha_config/#bitbucketoptions","title":"BitbucketOptions","text":"<p>(Appears on: Provider)</p> Field Type Description <code>team</code> string Team sets restrict logins to members of this team <code>repository</code> string Repository sets restrict logins to user with access to this repository"},{"location":"configuration/alpha_config/#claimsource","title":"ClaimSource","text":"<p>(Appears on: HeaderValue)</p> <p>ClaimSource allows loading a header value from a claim within the session</p> Field Type Description <code>claim</code> string Claim is the name of the claim in the session that the value should beloaded from. <code>prefix</code> string Prefix is an optional prefix that will be prepended to the value of theclaim if it is non-empty. <code>basicAuthPassword</code> SecretSource BasicAuthPassword converts this claim into a basic auth header.Note the value of claim will become the basic auth username and thebasicAuthPassword will be used as the password value."},{"location":"configuration/alpha_config/#duration","title":"Duration","text":""},{"location":"configuration/alpha_config/#string-alias","title":"(<code>string</code> alias)","text":"<p>(Appears on: Upstream)</p> <p>Duration is as string representation of a period of time. A duration string is a is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\". Valid time units are \"ns\", \"us\" (or \"\u00b5s\"), \"ms\", \"s\", \"m\", \"h\".</p>"},{"location":"configuration/alpha_config/#githuboptions","title":"GitHubOptions","text":"<p>(Appears on: Provider)</p> Field Type Description <code>org</code> string Org sets restrict logins to members of this organisation <code>team</code> string Team sets restrict logins to members of this team <code>repo</code> string Repo sets restrict logins to collaborators of this repository <code>token</code> string Token is the token to use when verifying repository collaboratorsit must have push access to the repository <code>users</code> []string Users allows users with these usernames to logineven if they do not belong to the specified org and team or collaborators"},{"location":"configuration/alpha_config/#gitlaboptions","title":"GitLabOptions","text":"<p>(Appears on: Provider)</p> Field Type Description <code>group</code> []string Group sets restrict logins to members of this group <code>projects</code> []string Projects restricts logins to members of these projects"},{"location":"configuration/alpha_config/#googleoptions","title":"GoogleOptions","text":"<p>(Appears on: Provider)</p> Field Type Description <code>group</code> []string Groups sets restrict logins to members of this Google group <code>adminEmail</code> string AdminEmail is the Google admin to impersonate for api calls <code>serviceAccountJson</code> string ServiceAccountJSON is the path to the service account json credentials <code>useApplicationDefaultCredentials</code> bool UseApplicationDefaultCredentials is a boolean whether to use Application Default Credentials instead of a ServiceAccountJSON <code>targetPrincipal</code> string TargetPrincipal is the Google Service Account used for Application Default Credentials"},{"location":"configuration/alpha_config/#header","title":"Header","text":"<p>(Appears on: AlphaOptions)</p> <p>Header represents an individual header that will be added to a request or response header.</p> Field Type Description <code>name</code> string Name is the header name to be used for this set of values.Names should be unique within a list of Headers. <code>preserveRequestValue</code> bool PreserveRequestValue determines whether any values for this headershould be preserved for the request to the upstream server.This option only applies to injected request headers.Defaults to false (headers that match this header will be stripped). <code>values</code> []HeaderValue Values contains the desired values for this header"},{"location":"configuration/alpha_config/#headervalue","title":"HeaderValue","text":"<p>(Appears on: Header)</p> <p>HeaderValue represents a single header value and the sources that can make up the header value</p> Field Type Description <code>value</code> []byte Value expects a base64 encoded string value. <code>fromEnv</code> string FromEnv expects the name of an environment variable. <code>fromFile</code> string FromFile expects a path to a file containing the secret value. <code>claim</code> string Claim is the name of the claim in the session that the value should beloaded from. <code>prefix</code> string Prefix is an optional prefix that will be prepended to the value of theclaim if it is non-empty. <code>basicAuthPassword</code> SecretSource BasicAuthPassword converts this claim into a basic auth header.Note the value of claim will become the basic auth username and thebasicAuthPassword will be used as the password value."},{"location":"configuration/alpha_config/#keycloakoptions","title":"KeycloakOptions","text":"<p>(Appears on: Provider)</p> Field Type Description <code>groups</code> []string Group enables to restrict login to members of indicated group <code>roles</code> []string Role enables to restrict login to users with role (only available when using the keycloak-oidc provider)"},{"location":"configuration/alpha_config/#logingovoptions","title":"LoginGovOptions","text":"<p>(Appears on: Provider)</p> Field Type Description <code>jwtKey</code> string JWTKey is a private key in PEM format used to sign JWT, <code>jwtKeyFile</code> string JWTKeyFile is a path to the private key file in PEM format used to sign the JWT <code>pubjwkURL</code> string PubJWKURL is the JWK pubkey access endpoint"},{"location":"configuration/alpha_config/#loginurlparameter","title":"LoginURLParameter","text":"<p>(Appears on: Provider)</p> <p>LoginURLParameter is the configuration for a single query parameter that can be passed through from the <code>/oauth2/start</code> endpoint to the IdP login URL.  The \"default\" option specifies the default value or values (if any) that will be passed to the IdP for this parameter, and \"allow\" is a list of options for ways in which this parameter can be set or overridden via the query string to <code>/oauth2/start</code>. If only a default is specified and no \"allow\" then the parameter is effectively fixed - the default value will always be used and anything passed to the start URL will be ignored.  If only \"allow\" is specified but no default then the parameter will only be passed on to the IdP if the caller provides it, and no value will be sent otherwise.</p> <p>Examples:</p>"},{"location":"configuration/alpha_config/#a-parameter-whose-value-is-fixed","title":"A parameter whose value is fixed","text":"<pre><code>name: organization\ndefault:\n- myorg\n</code></pre> <p>A parameter that is not passed by default, but may be set to one of a fixed set of values</p> <pre><code>name: prompt\nallow:\n- value: login\n- value: consent\n- value: select_account\n</code></pre> <p>A parameter that is passed by default but may be overridden by one of a fixed set of values</p> <pre><code>name: prompt\ndefault: [\"login\"]\nallow:\n- value: consent\n- value: select_account\n</code></pre> <p>A parameter that may be overridden, but only by values that match a regular expression.  For example to restrict <code>login_hint</code> to email addresses in your organization's domain:</p> <pre><code>name: login_hint\nallow:\n- pattern: '^[^@]*@example\\.com$'\n# this allows at most one \"@\" sign, and requires \"example.com\" domain.\n</code></pre> <p>Note that the YAML rules around exactly which characters are allowed and/or require escaping in different types of string literals are convoluted.  For regular expressions the single quoted form is simplest as backslash is not considered to be an escape character.  Alternatively use the \"chomped block\" format <code>|-</code>:</p> <pre><code>  - pattern: |-\n    ^[^@]*@example\\.com$\n</code></pre> <p>The hyphen is important, a <code>|</code> block would have a trailing newline character.</p> Field Type Description <code>name</code> string Name specifies the name of the query parameter. <code>default</code> []string (Optional) Default specifies a default value or values that will bepassed to the IdP if not overridden. <code>allow</code> []URLParameterRule (Optional) Allow specifies rules about how the default (if any) may beoverridden via the query string to <code>/oauth2/start</code>.  Onlyvalues that match one or more of the allow rules will beforwarded to the IdP."},{"location":"configuration/alpha_config/#oidcoptions","title":"OIDCOptions","text":"<p>(Appears on: Provider)</p> Field Type Description <code>issuerURL</code> string IssuerURL is the OpenID Connect issuer URLeg: https://accounts.google.com <code>insecureAllowUnverifiedEmail</code> bool InsecureAllowUnverifiedEmail prevents failures if an email address in an id_token is not verifieddefault set to 'false' <code>insecureSkipIssuerVerification</code> bool InsecureSkipIssuerVerification skips verification of ID token issuers. When false, ID Token Issuers must match the OIDC discovery URLdefault set to 'false' <code>insecureSkipNonce</code> bool InsecureSkipNonce skips verifying the ID Token's nonce claim that must matchthe random nonce sent in the initial OAuth flow. Otherwise, the nonce is checkedafter the initial OAuth redeem &amp; subsequent token refreshes.default set to 'true'Warning: In a future release, this will change to 'false' by default for enhanced security. <code>skipDiscovery</code> bool SkipDiscovery allows to skip OIDC discovery and use manually supplied Endpointsdefault set to 'false' <code>jwksURL</code> string JwksURL is the OpenID Connect JWKS URLeg: https://www.googleapis.com/oauth2/v3/certs <code>emailClaim</code> string EmailClaim indicates which claim contains the user email,default set to 'email' <code>groupsClaim</code> string GroupsClaim indicates which claim contains the user groupsdefault set to 'groups' <code>userIDClaim</code> string UserIDClaim indicates which claim contains the user IDdefault set to 'email' <code>audienceClaims</code> []string AudienceClaim allows to define any claim that is verified against the client idBy default <code>aud</code> claim is used for verification. <code>extraAudiences</code> []string ExtraAudiences is a list of additional audiences that are allowedto pass verification in addition to the client id."},{"location":"configuration/alpha_config/#provider","title":"Provider","text":"<p>(Appears on: Providers)</p> <p>Provider holds all configuration for a single provider</p> Field Type Description <code>clientID</code> string ClientID is the OAuth Client ID that is defined in the providerThis value is required for all providers. <code>clientSecret</code> string ClientSecret is the OAuth Client Secret that is defined in the providerThis value is required for all providers. <code>clientSecretFile</code> string ClientSecretFile is the name of the filecontaining the OAuth Client Secret, it will be used if ClientSecret is not set. <code>keycloakConfig</code> KeycloakOptions KeycloakConfig holds all configurations for Keycloak provider. <code>azureConfig</code> AzureOptions AzureConfig holds all configurations for Azure provider. <code>ADFSConfig</code> ADFSOptions ADFSConfig holds all configurations for ADFS provider. <code>bitbucketConfig</code> BitbucketOptions BitbucketConfig holds all configurations for Bitbucket provider. <code>githubConfig</code> GitHubOptions GitHubConfig holds all configurations for GitHubC provider. <code>gitlabConfig</code> GitLabOptions GitLabConfig holds all configurations for GitLab provider. <code>googleConfig</code> GoogleOptions GoogleConfig holds all configurations for Google provider. <code>oidcConfig</code> OIDCOptions OIDCConfig holds all configurations for OIDC provideror providers utilize OIDC configurations. <code>loginGovConfig</code> LoginGovOptions LoginGovConfig holds all configurations for LoginGov provider. <code>id</code> string ID should be a unique identifier for the provider.This value is required for all providers. <code>provider</code> ProviderType Type is the OAuth providermust be set from the supported providers group,otherwise 'Google' is set as default <code>name</code> string Name is the providers display nameif set, it will be shown to the users in the login page. <code>caFiles</code> []string CAFiles is a list of paths to CA certificates that should be used when connecting to the provider.If not specified, the default Go trust sources are used instead <code>useSystemTrustStore</code> bool UseSystemTrustStore determines if your custom CA files and the system trust store are usedIf set to true, your custom CA files and the system trust store are used otherwise only your custom CA files. <code>loginURL</code> string LoginURL is the authentication endpoint <code>loginURLParameters</code> []LoginURLParameter LoginURLParameters defines the parameters that can be passed from the start URL to the IdP login URL <code>redeemURL</code> string RedeemURL is the token redemption endpoint <code>profileURL</code> string ProfileURL is the profile access endpoint <code>skipClaimsFromProfileURL</code> bool SkipClaimsFromProfileURL allows to skip request to Profile URL for resolving claims not present in id_tokendefault set to 'false' <code>resource</code> string ProtectedResource is the resource that is protected (Azure AD and ADFS only) <code>validateURL</code> string ValidateURL is the access token validation endpoint <code>scope</code> string Scope is the OAuth scope specification <code>allowedGroups</code> []string AllowedGroups is a list of restrict logins to members of this group <code>code_challenge_method</code> string The code challenge method <code>backendLogoutURL</code> string URL to call to perform backend logout, <code>{id_token}</code> would be replaced by the actual <code>id_token</code> if available in the session"},{"location":"configuration/alpha_config/#providertype","title":"ProviderType","text":""},{"location":"configuration/alpha_config/#string-alias_1","title":"(<code>string</code> alias)","text":"<p>(Appears on: Provider)</p> <p>ProviderType is used to enumerate the different provider type options Valid options are: adfs, azure, bitbucket, digitalocean facebook, github, gitlab, google, keycloak, keycloak-oidc, linkedin, login.gov, nextcloud and oidc.</p>"},{"location":"configuration/alpha_config/#providers","title":"Providers","text":""},{"location":"configuration/alpha_config/#provider-alias","title":"([]Provider alias)","text":"<p>(Appears on: AlphaOptions)</p> <p>Providers is a collection of definitions for providers.</p>"},{"location":"configuration/alpha_config/#secretsource","title":"SecretSource","text":"<p>(Appears on: ClaimSource, HeaderValue, TLS)</p> <p>SecretSource references an individual secret value. Only one source within the struct should be defined at any time.</p> Field Type Description <code>value</code> []byte Value expects a base64 encoded string value. <code>fromEnv</code> string FromEnv expects the name of an environment variable. <code>fromFile</code> string FromFile expects a path to a file containing the secret value."},{"location":"configuration/alpha_config/#server","title":"Server","text":"<p>(Appears on: AlphaOptions)</p> <p>Server represents the configuration for an HTTP(S) server</p> Field Type Description <code>BindAddress</code> string BindAddress is the address on which to serve traffic.Leave blank or set to \"-\" to disable. <code>SecureBindAddress</code> string SecureBindAddress is the address on which to serve secure traffic.Leave blank or set to \"-\" to disable. <code>TLS</code> TLS TLS contains the information for loading the certificate and key for thesecure traffic and further configuration for the TLS server."},{"location":"configuration/alpha_config/#tls","title":"TLS","text":"<p>(Appears on: Server)</p> <p>TLS contains the information for loading a TLS certificate and key as well as an optional minimal TLS version that is acceptable.</p> Field Type Description <code>Key</code> SecretSource Key is the TLS key data to use.Typically this will come from a file. <code>Cert</code> SecretSource Cert is the TLS certificate data to use.Typically this will come from a file. <code>MinVersion</code> string MinVersion is the minimal TLS version that is acceptable.E.g. Set to \"TLS1.3\" to select TLS version 1.3 <code>CipherSuites</code> []string CipherSuites is a list of TLS cipher suites that are allowed.E.g.:- TLS_RSA_WITH_RC4_128_SHA- TLS_RSA_WITH_AES_256_GCM_SHA384If not specified, the default Go safe cipher list is used.List of valid cipher suites can be found in the crypto/tls documentation."},{"location":"configuration/alpha_config/#urlparameterrule","title":"URLParameterRule","text":"<p>(Appears on: LoginURLParameter)</p> <p>URLParameterRule represents a rule by which query parameters passed to the <code>/oauth2/start</code> endpoint are checked to determine whether they are valid overrides for the given parameter passed to the IdP's login URL.  Either Value or Pattern should be supplied, not both.</p> Field Type Description <code>value</code> string A Value rule matches just this specific value <code>pattern</code> string A Pattern rule gives a regular expression that must be matched bysome substring of the value.  The expression is not automaticallyanchored to the start and end of the value, if you want to restrictthe whole parameter value you must anchor it yourself with <code>^</code> and <code>$</code>."},{"location":"configuration/alpha_config/#upstream","title":"Upstream","text":"<p>(Appears on: UpstreamConfig)</p> <p>Upstream represents the configuration for an upstream server. Requests will be proxied to this upstream if the path matches the request path.</p> Field Type Description <code>id</code> string ID should be a unique identifier for the upstream.This value is required for all upstreams. <code>path</code> string Path is used to map requests to the upstream server.The closest match will take precedence and all Paths must be unique.Path can also take a pattern when used with RewriteTarget.Path segments can be captured and matched using regular experessions.Eg:- <code>^/foo$</code>: Match only the explicit path <code>/foo</code>- <code>^/bar/$</code>: Match any path prefixed with <code>/bar/</code>- <code>^/baz/(.*)$</code>: Match any path prefixed with <code>/baz</code> and capture the remaining path for use with RewriteTarget <code>rewriteTarget</code> string RewriteTarget allows users to rewrite the request path before it is sent tothe upstream server.Use the Path to capture segments for reuse within the rewrite target.Eg: With a Path of <code>^/baz/(.*)</code>, a RewriteTarget of <code>/foo/$1</code> would rewritethe request <code>/baz/abc/123</code> to <code>/foo/abc/123</code> before proxying to theupstream server. <code>uri</code> string The URI of the upstream server. This may be an HTTP(S) server of a Filebased URL. It may include a path, in which case all requests will be servedunder that path.Eg:- http://localhost:8080- https://service.localhost- https://service.localhost/path- file://host/pathIf the URI's path is \"/base\" and the incoming request was for \"/dir\",the upstream request will be for \"/base/dir\". <code>insecureSkipTLSVerify</code> bool InsecureSkipTLSVerify will skip TLS verification of upstream HTTPS hosts.This option is insecure and will allow potential Man-In-The-Middle attacksbetween OAuth2 Proxy and the upstream server.Defaults to false. <code>static</code> bool Static will make all requests to this upstream have a static response.The response will have a body of \"Authenticated\" and a response codematching StaticCode.If StaticCode is not set, the response will return a 200 response. <code>staticCode</code> int StaticCode determines the response code for the Static response.This option can only be used with Static enabled. <code>flushInterval</code> Duration FlushInterval is the period between flushing the response buffer whenstreaming response from the upstream.Defaults to 1 second. <code>passHostHeader</code> bool PassHostHeader determines whether the request host header should be proxiedto the upstream server.Defaults to true. <code>proxyWebSockets</code> bool ProxyWebSockets enables proxying of websockets to upstream serversDefaults to true. <code>timeout</code> Duration Timeout is the maximum duration the server will wait for a response from the upstream server.Defaults to 30 seconds."},{"location":"configuration/alpha_config/#upstreamconfig","title":"UpstreamConfig","text":"<p>(Appears on: AlphaOptions)</p> <p>UpstreamConfig is a collection of definitions for upstream servers.</p> Field Type Description <code>proxyRawPath</code> bool ProxyRawPath will pass the raw url path to upstream allowing for urlslike: \"/%2F/\" which would otherwise be redirected to \"/\" <code>upstreams</code> []Upstream Upstreams represents the configuration for the upstream servers.Requests will be proxied to this upstream if the path matches the request path."},{"location":"configuration/overview/","title":"Overview","text":"<p><code>oauth2-proxy</code> can be configured via command line options, environment variables or config file (in decreasing order of precedence, i.e. command line options will overwrite environment variables and environment variables will overwrite configuration file settings).</p>"},{"location":"configuration/overview/#generating-a-cookie-secret","title":"Generating a Cookie Secret","text":"<p>To generate a strong cookie secret use one of the below commands:</p> <p>import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem';</p> <p> <pre><code>python -c 'import os,base64; print(base64.urlsafe_b64encode(os.urandom(32)).decode())'\n</code></pre> <p> <pre><code>dd if=/dev/urandom bs=32 count=1 2&gt;/dev/null | base64 | tr -d -- '\\n' | tr -- '+/' '-_' ; echo\n</code></pre> <p> <pre><code>openssl rand -base64 32 | tr -- '+/' '-_'\n</code></pre> <p> <pre><code># Add System.Web assembly to session, just in case\nAdd-Type -AssemblyName System.Web\n[Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes([System.Web.Security.Membership]::GeneratePassword(32,4))).Replace(\"+\",\"-\").Replace(\"/\",\"_\")\n</code></pre> <p> <pre><code># Valid 32 Byte Base64 URL encoding set that will decode to 24 []byte AES-192 secret\nresource \"random_password\" \"cookie_secret\" {\n  length           = 32\n  override_special = \"-_\"\n}\n</code></pre> <p> </p>"},{"location":"configuration/overview/#config-file","title":"Config File","text":"<p>Every command line argument can be specified in a config file by replacing hyphens (-) with underscores (_). If the argument can be specified multiple times, the config option should be plural (trailing s).</p> <p>An example oauth2-proxy.cfg config file is in the contrib directory. It can be used by specifying <code>--config=/etc/oauth2-proxy.cfg</code></p>"},{"location":"configuration/overview/#command-line-options","title":"Command Line Options","text":"Option Type Description Default <code>--acr-values</code> string optional, see docs <code>\"\"</code> <code>--allow-query-semicolons</code> bool allow the use of semicolons in query args (required for some legacy applications) <code>false</code> <code>--api-route</code> string | list return HTTP 401 instead of redirecting to authentication server if token is not valid. Format: path_regex <code>--approval-prompt</code> string OAuth approval_prompt <code>\"force\"</code> <code>--auth-logging</code> bool Log authentication attempts true <code>--auth-logging-format</code> string Template for authentication log lines see Logging Configuration <code>--authenticated-emails-file</code> string authenticate against emails via file (one per line) <code>--azure-tenant</code> string go to a tenant-specific or common (tenant-independent) endpoint. <code>\"common\"</code> <code>--backend-logout-url</code> string URL to perform backend logout, if you use <code>{id_token}</code> in the url it will be replaced by the actual <code>id_token</code> of the user session <code>--basic-auth-password</code> string the password to set when passing the HTTP Basic Auth header <code>--client-id</code> string the OAuth Client ID, e.g. <code>\"123456.apps.googleusercontent.com\"</code> <code>--client-secret</code> string the OAuth Client Secret <code>--client-secret-file</code> string the file with OAuth Client Secret <code>--code-challenge-method</code> string use PKCE code challenges with the specified method. Either 'plain' or 'S256' (recommended) <code>--config</code> string path to config file <code>--cookie-domain</code> string | list Optional cookie domains to force cookies to (e.g. <code>.yourcompany.com</code>). The longest domain matching the request's host will be used (or the shortest cookie domain if there is no match). <code>--cookie-expire</code> duration expire timeframe for cookie. If set to 0, cookie becomes a session-cookie which will expire when the browser is closed. 168h0m0s <code>--cookie-httponly</code> bool set HttpOnly cookie flag true <code>--cookie-name</code> string the name of the cookie that the oauth_proxy creates. Should be changed to use a cookie prefix (<code>__Host-</code> or <code>__Secure-</code>) if <code>--cookie-secure</code> is set. <code>\"_oauth2_proxy\"</code> <code>--cookie-path</code> string an optional cookie path to force cookies to (e.g. <code>/poc/</code>) <code>\"/\"</code> <code>--cookie-refresh</code> duration refresh the cookie after this duration; <code>0</code> to disable; not supported by all providers\u00a0<sup>1</sup> <code>--cookie-secret</code> string the seed string for secure cookies (optionally base64 encoded) <code>--cookie-secure</code> bool set secure (HTTPS only) cookie flag true <code>--cookie-samesite</code> string set SameSite cookie attribute (<code>\"lax\"</code>, <code>\"strict\"</code>, <code>\"none\"</code>, or <code>\"\"</code>). <code>\"\"</code> <code>--cookie-csrf-per-request</code> bool Enable having different CSRF cookies per request, making it possible to have parallel requests. false <code>--cookie-csrf-expire</code> duration expire timeframe for CSRF cookie 15m <code>--custom-templates-dir</code> string path to custom html templates <code>--custom-sign-in-logo</code> string path or a URL to an custom image for the sign_in page logo. Use <code>\"-\"</code> to disable default logo. <code>--display-htpasswd-form</code> bool display username / password login form if an htpasswd file is provided true <code>--email-domain</code> string | list authenticate emails with the specified domain (may be given multiple times). Use <code>*</code> to authenticate any email <code>--errors-to-info-log</code> bool redirects error-level logging to default log channel instead of stderr false <code>--extra-jwt-issuers</code> string if <code>--skip-jwt-bearer-tokens</code> is set, a list of extra JWT <code>issuer=audience</code> (see a token's <code>iss</code>, <code>aud</code> fields) pairs (where the issuer URL has a <code>.well-known/openid-configuration</code> or a <code>.well-known/jwks.json</code>) <code>--exclude-logging-path</code> string comma separated list of paths to exclude from logging, e.g. <code>\"/ping,/path2\"</code> <code>\"\"</code> (no paths excluded) <code>--flush-interval</code> duration period between flushing response buffers when streaming responses <code>\"1s\"</code> <code>--force-https</code> bool enforce https redirect <code>false</code> <code>--force-json-errors</code> bool force JSON errors instead of HTTP error pages or redirects <code>false</code> <code>--banner</code> string custom (html) banner string. Use <code>\"-\"</code> to disable default banner. <code>--footer</code> string custom (html) footer string. Use <code>\"-\"</code> to disable default footer. <code>--github-org</code> string restrict logins to members of this organisation <code>--github-team</code> string restrict logins to members of any of these teams (slug), separated by a comma <code>--github-repo</code> string restrict logins to collaborators of this repository formatted as <code>orgname/repo</code> <code>--github-token</code> string the token to use when verifying repository collaborators (must have push access to the repository) <code>--github-user</code> string | list To allow users to login by username even if they do not belong to the specified org and team or collaborators <code>--gitlab-group</code> string | list restrict logins to members of any of these groups (slug), separated by a comma <code>--gitlab-projects</code> string | list restrict logins to members of any of these projects (may be given multiple times) formatted as <code>orgname/repo=accesslevel</code>. Access level should be a value matching Gitlab access levels, defaulted to 20 if absent <code>--google-admin-email</code> string the google admin to impersonate for api calls <code>--google-group</code> string restrict logins to members of this google group (may be given multiple times). <code>--google-service-account-json</code> string the path to the service account json credentials <code>--google-use-application-default-credentials</code> bool use application default credentials instead of service account json (i.e. GKE Workload Identity) <code>--google-target-principal</code> bool the target principal to impersonate when using ADC defaults to the service account configured for ADC <code>--htpasswd-file</code> string additionally authenticate against a htpasswd file. Entries must be created with <code>htpasswd -B</code> for bcrypt encryption <code>--htpasswd-user-group</code> string | list the groups to be set on sessions for htpasswd users <code>--http-address</code> string <code>[http://]&lt;addr&gt;:&lt;port&gt;</code> or <code>unix://&lt;path&gt;</code> to listen on for HTTP clients. Square brackets are required for ipv6 address, e.g. <code>http://[::1]:4180</code> <code>\"127.0.0.1:4180\"</code> <code>--https-address</code> string <code>[https://]&lt;addr&gt;:&lt;port&gt;</code> to listen on for HTTPS clients. Square brackets are required for ipv6 address, e.g. <code>https://[::1]:443</code> <code>\":443\"</code> <code>--logging-compress</code> bool Should rotated log files be compressed using gzip false <code>--logging-filename</code> string File to log requests to, empty for <code>stdout</code> <code>\"\"</code> (stdout) <code>--logging-local-time</code> bool Use local time in log files and backup filenames instead of UTC true (local time) <code>--logging-max-age</code> int Maximum number of days to retain old log files 7 <code>--logging-max-backups</code> int Maximum number of old log files to retain; 0 to disable 0 <code>--logging-max-size</code> int Maximum size in megabytes of the log file before rotation 100 <code>--jwt-key</code> string private key in PEM format used to sign JWT, so that you can say something like <code>--jwt-key=\"${OAUTH2_PROXY_JWT_KEY}\"</code>: required by login.gov <code>--jwt-key-file</code> string path to the private key file in PEM format used to sign the JWT so that you can say something like <code>--jwt-key-file=/etc/ssl/private/jwt_signing_key.pem</code>: required by login.gov <code>--login-url</code> string Authentication endpoint <code>--insecure-oidc-allow-unverified-email</code> bool don't fail if an email address in an id_token is not verified false <code>--insecure-oidc-skip-issuer-verification</code> bool allow the OIDC issuer URL to differ from the expected (currently required for Azure multi-tenant compatibility) false <code>--insecure-oidc-skip-nonce</code> bool skip verifying the OIDC ID Token's nonce claim true <code>--oidc-issuer-url</code> string the OpenID Connect issuer URL, e.g. <code>\"https://accounts.google.com\"</code> <code>--oidc-jwks-url</code> string OIDC JWKS URI for token verification; required if OIDC discovery is disabled <code>--oidc-email-claim</code> string which OIDC claim contains the user's email <code>\"email\"</code> <code>--oidc-groups-claim</code> string which OIDC claim contains the user groups <code>\"groups\"</code> <code>--oidc-audience-claim</code> string which OIDC claim contains the audience <code>\"aud\"</code> <code>--oidc-extra-audience</code> string | list additional audiences which are allowed to pass verification <code>\"[]\"</code> <code>--pass-access-token</code> bool pass OAuth access_token to upstream via X-Forwarded-Access-Token header. When used with <code>--set-xauthrequest</code> this adds the X-Auth-Request-Access-Token header to the response false <code>--pass-authorization-header</code> bool pass OIDC IDToken to upstream via Authorization Bearer header false <code>--pass-basic-auth</code> bool pass HTTP Basic Auth, X-Forwarded-User, X-Forwarded-Email and X-Forwarded-Preferred-Username information to upstream true <code>--prefer-email-to-user</code> bool Prefer to use the Email address as the Username when passing information to upstream. Will only use Username if Email is unavailable, e.g. htaccess authentication. Used in conjunction with <code>--pass-basic-auth</code> and <code>--pass-user-headers</code> false <code>--pass-host-header</code> bool pass the request Host Header to upstream true <code>--pass-user-headers</code> bool pass X-Forwarded-User, X-Forwarded-Groups, X-Forwarded-Email and X-Forwarded-Preferred-Username information to upstream true <code>--profile-url</code> string Profile access endpoint <code>--skip-claims-from-profile-url</code> bool skip request to Profile URL for resolving claims not present in id_token false <code>--prompt</code> string OIDC prompt; if present, <code>approval-prompt</code> is ignored <code>\"\"</code> <code>--provider</code> string OAuth provider google <code>--provider-ca-file</code> string | list Paths to CA certificates that should be used when connecting to the provider. If not specified, the default Go trust sources are used instead. <code>--use-system-trust-store</code> bool Determines if <code>provider-ca-file</code> files and the system trust store are used. If set to true, your custom CA files and the system trust store are used otherwise only your custom CA files. false <code>--provider-display-name</code> string Override the provider's name with the given string; used for the sign-in page (depends on provider) <code>--ping-path</code> string the ping endpoint that can be used for basic health checks <code>\"/ping\"</code> <code>--ping-user-agent</code> string a User-Agent that can be used for basic health checks <code>\"\"</code> (don't check user agent) <code>--ready-path</code> string the ready endpoint that can be used for deep health checks <code>\"/ready\"</code> <code>--metrics-address</code> string the address prometheus metrics will be scraped from <code>\"\"</code> <code>--proxy-prefix</code> string the url root path that this proxy should be nested under (e.g. /<code>&lt;oauth2&gt;/sign_in</code>) <code>\"/oauth2\"</code> <code>--proxy-websockets</code> bool enables WebSocket proxying true <code>--pubjwk-url</code> string JWK pubkey access endpoint: required by login.gov <code>--real-client-ip-header</code> string Header used to determine the real IP of the client, requires <code>--reverse-proxy</code> to be set (one of: X-Forwarded-For, X-Real-IP, or X-ProxyUser-IP) X-Real-IP <code>--redeem-url</code> string Token redemption endpoint <code>--redirect-url</code> string the OAuth Redirect URL, e.g. <code>\"https://internalapp.yourcompany.com/oauth2/callback\"</code> <code>--relative-redirect-url</code> bool allow relative OAuth Redirect URL.` <code>--redis-cluster-connection-urls</code> string | list List of Redis cluster connection URLs (e.g. <code>redis://HOST[:PORT]</code>). Used in conjunction with <code>--redis-use-cluster</code> <code>--redis-connection-url</code> string URL of redis server for redis session storage (e.g. <code>redis://HOST[:PORT]</code>) <code>--redis-insecure-skip-tls-verify</code> bool skip TLS verification when connecting to Redis false <code>--redis-password</code> string Redis password. Applicable for all Redis configurations. Will override any password set in <code>--redis-connection-url</code> <code>--redis-sentinel-password</code> string Redis sentinel password. Used only for sentinel connection; any redis node passwords need to use <code>--redis-password</code> <code>--redis-sentinel-master-name</code> string Redis sentinel master name. Used in conjunction with <code>--redis-use-sentinel</code> <code>--redis-sentinel-connection-urls</code> string | list List of Redis sentinel connection URLs (e.g. <code>redis://HOST[:PORT]</code>). Used in conjunction with <code>--redis-use-sentinel</code> <code>--redis-use-cluster</code> bool Connect to redis cluster. Must set <code>--redis-cluster-connection-urls</code> to use this feature false <code>--redis-use-sentinel</code> bool Connect to redis via sentinels. Must set <code>--redis-sentinel-master-name</code> and <code>--redis-sentinel-connection-urls</code> to use this feature false <code>--redis-connection-idle-timeout</code> int Redis connection idle timeout seconds. If Redis timeout option is set to non-zero, the <code>--redis-connection-idle-timeout</code> must be less than Redis timeout option. Example: if either redis.conf includes <code>timeout 15</code> or using <code>CONFIG SET timeout 15</code> the <code>--redis-connection-idle-timeout</code> must be at least <code>--redis-connection-idle-timeout=14</code> 0 <code>--request-id-header</code> string Request header to use as the request ID in logging X-Request-Id <code>--request-logging</code> bool Log requests true <code>--request-logging-format</code> string Template for request log lines see Logging Configuration <code>--resource</code> string The resource that is protected (Azure AD only) <code>--reverse-proxy</code> bool are we running behind a reverse proxy, controls whether headers like X-Real-IP are accepted and allows X-Forwarded-{Proto,Host,Uri} headers to be used on redirect selection false <code>--scope</code> string OAuth scope specification <code>--session-cookie-minimal</code> bool strip OAuth tokens from cookie session stores if they aren't needed (cookie session store only) false <code>--session-store-type</code> string Session data storage backend; redis or cookie cookie <code>--set-xauthrequest</code> bool set X-Auth-Request-User, X-Auth-Request-Groups, X-Auth-Request-Email and X-Auth-Request-Preferred-Username response headers (useful in Nginx auth_request mode). When used with <code>--pass-access-token</code>, X-Auth-Request-Access-Token is added to response headers. false <code>--set-authorization-header</code> bool set Authorization Bearer response header (useful in Nginx auth_request mode) false <code>--set-basic-auth</code> bool set HTTP Basic Auth information in response (useful in Nginx auth_request mode) false <code>--show-debug-on-error</code> bool show detailed error information on error pages (WARNING: this may contain sensitive information - do not use in production) false <code>--signature-key</code> string GAP-Signature request signature key (algorithm:secretkey) <code>--silence-ping-logging</code> bool disable logging of requests to ping &amp; ready endpoints false <code>--skip-auth-preflight</code> bool will skip authentication for OPTIONS requests false <code>--skip-auth-regex</code> string | list (DEPRECATED for <code>--skip-auth-route</code>) bypass authentication for requests paths that match (may be given multiple times) <code>--skip-auth-route</code> string | list bypass authentication for requests that match the method &amp; path. Format: method=path_regex OR method!=path_regex. For all methods: path_regex OR !=path_regex <code>--skip-auth-strip-headers</code> bool strips <code>X-Forwarded-*</code> style authentication headers &amp; <code>Authorization</code> header if they would be set by oauth2-proxy true <code>--skip-jwt-bearer-tokens</code> bool will skip requests that have verified JWT bearer tokens (the token must have <code>aud</code> that matches this client id or one of the extras from <code>extra-jwt-issuers</code>) false <code>--skip-oidc-discovery</code> bool bypass OIDC endpoint discovery. <code>--login-url</code>, <code>--redeem-url</code> and <code>--oidc-jwks-url</code> must be configured in this case false <code>--skip-provider-button</code> bool will skip sign-in-page to directly reach the next step: oauth/start false <code>--ssl-insecure-skip-verify</code> bool skip validation of certificates presented when using HTTPS providers false <code>--ssl-upstream-insecure-skip-verify</code> bool skip validation of certificates presented when using HTTPS upstreams false <code>--standard-logging</code> bool Log standard runtime information true <code>--standard-logging-format</code> string Template for standard log lines see Logging Configuration <code>--tls-cert-file</code> string path to certificate file <code>--tls-cipher-suite</code> string | list Restricts TLS cipher suites used by server to those listed (e.g. TLS_RSA_WITH_RC4_128_SHA) (may be given multiple times). If not specified, the default Go safe cipher list is used. List of valid cipher suites can be found in the crypto/tls documentation. <code>--tls-key-file</code> string path to private key file <code>--tls-min-version</code> string minimum TLS version that is acceptable, either <code>\"TLS1.2\"</code> or <code>\"TLS1.3\"</code> <code>\"TLS1.2\"</code> <code>--upstream</code> string | list the http url(s) of the upstream endpoint, file:// paths for static files or <code>static://&lt;status_code&gt;</code> for static response. Routing is based on the path <code>--upstream-timeout</code> duration maximum amount of time the server will wait for a response from the upstream 30s <code>--allowed-group</code> string | list restrict logins to members of this group (may be given multiple times) <code>--allowed-role</code> string | list restrict logins to users with this role (may be given multiple times). Only works with the keycloak-oidc provider. <code>--validate-url</code> string Access token validation endpoint <code>--version</code> n/a print version string <code>--whitelist-domain</code> string | list allowed domains for redirection after authentication. Prefix domain with a <code>.</code> or a <code>*.</code> to allow subdomains (e.g. <code>.example.com</code>, <code>*.example.com</code>)\u00a0<sup>2</sup> <code>--trusted-ip</code> string | list list of IPs or CIDR ranges to allow to bypass authentication (may be given multiple times). When combined with <code>--reverse-proxy</code> and optionally <code>--real-client-ip-header</code> this will evaluate the trust of the IP stored in an HTTP header by a reverse proxy rather than the layer-3/4 remote address. WARNING: trusting IPs has inherent security flaws, especially when obtaining the IP address from an HTTP header (reverse-proxy mode). Use this option only if you understand the risks and how to manage them. <code>--encode-state</code> bool encode the state parameter as UrlEncodedBase64 false <p>See below for provider specific options</p>"},{"location":"configuration/overview/#upstreams-configuration","title":"Upstreams Configuration","text":"<p><code>oauth2-proxy</code> supports having multiple upstreams, and has the option to pass requests on to HTTP(S) servers, unix socket or serve static files from the file system.</p> <p>HTTP and HTTPS upstreams are configured by providing a URL such as <code>http://127.0.0.1:8080/</code> for the upstream parameter. . This will forward all authenticated requests to the upstream server. If you instead provide <code>http://127.0.0.1:8080/some/path/</code> then it will only be requests that start with <code>/some/path/</code> which are forwarded to the upstream.</p> <p>Unix socket upstreams are configured as <code>unix:///path/to/unix.sock</code>.</p> <p>Static file paths are configured as a file:// URL. <code>file:///var/www/static/</code> will serve the files from that directory at <code>http://[oauth2-proxy url]/var/www/static/</code>, which may not be what you want. You can provide the path to where the files should be available by adding a fragment to the configured URL. The value of the fragment will then be used to specify which path the files are available at, e.g. <code>file:///var/www/static/#/static/</code> will make <code>/var/www/static/</code> available at <code>http://[oauth2-proxy url]/static/</code>.</p> <p>Multiple upstreams can either be configured by supplying a comma separated list to the <code>--upstream</code> parameter, supplying the parameter multiple times or providing a list in the config file. When multiple upstreams are used routing to them will be based on the path they are set up with.</p>"},{"location":"configuration/overview/#environment-variables","title":"Environment variables","text":"<p>Every command line argument can be specified as an environment variable by prefixing it with <code>OAUTH2_PROXY_</code>, capitalising it, and replacing hyphens (<code>-</code>) with underscores (<code>_</code>). If the argument can be specified multiple times, the environment variable should be plural (trailing <code>S</code>).</p> <p>This is particularly useful for storing secrets outside a configuration file or the command line.</p> <p>For example, the <code>--cookie-secret</code> flag becomes <code>OAUTH2_PROXY_COOKIE_SECRET</code>, and the <code>--email-domain</code> flag becomes <code>OAUTH2_PROXY_EMAIL_DOMAINS</code>.</p>"},{"location":"configuration/overview/#logging-configuration","title":"Logging Configuration","text":"<p>By default, OAuth2 Proxy logs all output to stdout. Logging can be configured to output to a rotating log file using the <code>--logging-filename</code> command.</p> <p>If logging to a file you can also configure the maximum file size (<code>--logging-max-size</code>), age (<code>--logging-max-age</code>), max backup logs (<code>--logging-max-backups</code>), and if backup logs should be compressed (<code>--logging-compress</code>).</p> <p>There are three different types of logging: standard, authentication, and HTTP requests. These can each be enabled or disabled with <code>--standard-logging</code>, <code>--auth-logging</code>, and <code>--request-logging</code>.</p> <p>Each type of logging has its own configurable format and variables. By default, these formats are similar to the Apache Combined Log.</p> <p>Logging of requests to the <code>/ping</code> endpoint (or using <code>--ping-user-agent</code>) and the <code>/ready</code> endpoint can be disabled with <code>--silence-ping-logging</code> reducing log volume.</p>"},{"location":"configuration/overview/#auth-log-format","title":"Auth Log Format","text":"<p>Authentication logs are logs which are guaranteed to contain a username or email address of a user attempting to authenticate. These logs are output by default in the below format:</p> <pre><code>&lt;REMOTE_ADDRESS&gt; - &lt;REQUEST ID&gt; - &lt;user@domain.com&gt; [19/Mar/2015:17:20:19 -0400] [&lt;STATUS&gt;] &lt;MESSAGE&gt;\n</code></pre> <p>The status block will contain one of the below strings:</p> <ul> <li><code>AuthSuccess</code> If a user has authenticated successfully by any method</li> <li><code>AuthFailure</code> If the user failed to authenticate explicitly</li> <li><code>AuthError</code> If there was an unexpected error during authentication</li> </ul> <p>If you require a different format than that, you can configure it with the <code>--auth-logging-format</code> flag. The default format is configured as follows:</p> <pre><code>{{.Client}} - {{.RequestID}} - {{.Username}} [{{.Timestamp}}] [{{.Status}}] {{.Message}}\n</code></pre> <p>Available variables for auth logging:</p> Variable Example Description Client 74.125.224.72 The client/remote IP address. Will use the X-Real-IP header it if exists &amp; reverse-proxy is set to true. Host domain.com The value of the Host header. Message Authenticated via OAuth2 The details of the auth attempt. Protocol HTTP/1.0 The request protocol. RequestID 00010203-0405-4607-8809-0a0b0c0d0e0f The request ID pulled from the <code>--request-id-header</code>. Random UUID if empty RequestMethod GET The request method. Timestamp 19/Mar/2015:17:20:19 -0400 The date and time of the logging event. UserAgent - The full user agent as reported by the requesting client. Username username@email.com The email or username of the auth request. Status AuthSuccess The status of the auth request. See above for details."},{"location":"configuration/overview/#request-log-format","title":"Request Log Format","text":"<p>HTTP request logs will output by default in the below format:</p> <pre><code>&lt;REMOTE_ADDRESS&gt; - &lt;REQUEST ID&gt; - &lt;user@domain.com&gt; [19/Mar/2015:17:20:19 -0400] &lt;HOST_HEADER&gt; GET &lt;UPSTREAM_HOST&gt; \"/path/\" HTTP/1.1 \"&lt;USER_AGENT&gt;\" &lt;RESPONSE_CODE&gt; &lt;RESPONSE_BYTES&gt; &lt;REQUEST_DURATION&gt;\n</code></pre> <p>If you require a different format than that, you can configure it with the <code>--request-logging-format</code> flag. The default format is configured as follows:</p> <pre><code>{{.Client}} - {{.RequestID}} - {{.Username}} [{{.Timestamp}}] {{.Host}} {{.RequestMethod}} {{.Upstream}} {{.RequestURI}} {{.Protocol}} {{.UserAgent}} {{.StatusCode}} {{.ResponseSize}} {{.RequestDuration}}\n</code></pre> <p>Available variables for request logging:</p> Variable Example Description Client 74.125.224.72 The client/remote IP address. Will use the X-Real-IP header it if exists &amp; reverse-proxy is set to true. Host domain.com The value of the Host header. Protocol HTTP/1.0 The request protocol. RequestDuration 0.001 The time in seconds that a request took to process. RequestID 00010203-0405-4607-8809-0a0b0c0d0e0f The request ID pulled from the <code>--request-id-header</code>. Random UUID if empty RequestMethod GET The request method. RequestURI \"/oauth2/auth\" The URI path of the request. ResponseSize 12 The size in bytes of the response. StatusCode 200 The HTTP status code of the response. Timestamp 19/Mar/2015:17:20:19 -0400 The date and time of the logging event. Upstream - The upstream data of the HTTP request. UserAgent - The full user agent as reported by the requesting client. Username username@email.com The email or username of the auth request."},{"location":"configuration/overview/#standard-log-format","title":"Standard Log Format","text":"<p>All other logging that is not covered by the above two types of logging will be output in this standard logging format. This includes configuration information at startup and errors that occur outside of a session. The default format is below:</p> <pre><code>[19/Mar/2015:17:20:19 -0400] [main.go:40] &lt;MESSAGE&gt;\n</code></pre> <p>If you require a different format than that, you can configure it with the <code>--standard-logging-format</code> flag. The default format is configured as follows:</p> <pre><code>[{{.Timestamp}}] [{{.File}}] {{.Message}}\n</code></pre> <p>Available variables for standard logging:</p> Variable Example Description Timestamp 19/Mar/2015:17:20:19 -0400 The date and time of the logging event. File main.go:40 The file and line number of the logging statement. Message HTTP: listening on 127.0.0.1:4180 The details of the log statement."},{"location":"configuration/overview/#configuring-for-use-with-the-nginx-auth_request-directive","title":"Configuring for use with the Nginx <code>auth_request</code> directive","text":"<p>This option requires <code>--reverse-proxy</code> option to be set.</p> <p>The Nginx <code>auth_request</code> directive allows Nginx to authenticate requests via the oauth2-proxy's <code>/auth</code> endpoint, which only returns a 202 Accepted response or a 401 Unauthorized response without proxying the request through. For example:</p> <pre><code>server {\n  listen 443 ssl;\n  server_name ...;\n  include ssl/ssl.conf;\n\n  location /oauth2/ {\n    proxy_pass       http://127.0.0.1:4180;\n    proxy_set_header Host                    $host;\n    proxy_set_header X-Real-IP               $remote_addr;\n    proxy_set_header X-Auth-Request-Redirect $request_uri;\n    # or, if you are handling multiple domains:\n    # proxy_set_header X-Auth-Request-Redirect $scheme://$host$request_uri;\n  }\n  location = /oauth2/auth {\n    proxy_pass       http://127.0.0.1:4180;\n    proxy_set_header Host             $host;\n    proxy_set_header X-Real-IP        $remote_addr;\n    proxy_set_header X-Forwarded-Uri  $request_uri;\n    # nginx auth_request includes headers but not body\n    proxy_set_header Content-Length   \"\";\n    proxy_pass_request_body           off;\n  }\n\n  location / {\n    auth_request /oauth2/auth;\n    error_page 401 =403 /oauth2/sign_in;\n\n    # pass information via X-User and X-Email headers to backend,\n    # requires running with --set-xauthrequest flag\n    auth_request_set $user   $upstream_http_x_auth_request_user;\n    auth_request_set $email  $upstream_http_x_auth_request_email;\n    proxy_set_header X-User  $user;\n    proxy_set_header X-Email $email;\n\n    # if you enabled --pass-access-token, this will pass the token to the backend\n    auth_request_set $token  $upstream_http_x_auth_request_access_token;\n    proxy_set_header X-Access-Token $token;\n\n    # if you enabled --cookie-refresh, this is needed for it to work with auth_request\n    auth_request_set $auth_cookie $upstream_http_set_cookie;\n    add_header Set-Cookie $auth_cookie;\n\n    # When using the --set-authorization-header flag, some provider's cookies can exceed the 4kb\n    # limit and so the OAuth2 Proxy splits these into multiple parts.\n    # Nginx normally only copies the first `Set-Cookie` header from the auth_request to the response,\n    # so if your cookies are larger than 4kb, you will need to extract additional cookies manually.\n    auth_request_set $auth_cookie_name_upstream_1 $upstream_cookie_auth_cookie_name_1;\n\n    # Extract the Cookie attributes from the first Set-Cookie header and append them\n    # to the second part ($upstream_cookie_* variables only contain the raw cookie content)\n    if ($auth_cookie ~* \"(; .*)\") {\n        set $auth_cookie_name_0 $auth_cookie;\n        set $auth_cookie_name_1 \"auth_cookie_name_1=$auth_cookie_name_upstream_1$1\";\n    }\n\n    # Send both Set-Cookie headers now if there was a second part\n    if ($auth_cookie_name_upstream_1) {\n        add_header Set-Cookie $auth_cookie_name_0;\n        add_header Set-Cookie $auth_cookie_name_1;\n    }\n\n    proxy_pass http://backend/;\n    # or \"root /path/to/site;\" or \"fastcgi_pass ...\" etc\n  }\n}\n</code></pre> <p>When you use ingress-nginx in Kubernetes, you MUST use <code>kubernetes/ingress-nginx</code> (which includes the Lua module) and the following configuration snippet for your <code>Ingress</code>. Variables set with <code>auth_request_set</code> are not <code>set</code>-able in plain nginx config when the location is processed via <code>proxy_pass</code> and then may only be processed by Lua. Note that <code>nginxinc/kubernetes-ingress</code> does not include the Lua module.</p> <p><pre><code>nginx.ingress.kubernetes.io/auth-response-headers: Authorization\nnginx.ingress.kubernetes.io/auth-signin: https://$host/oauth2/start?rd=$escaped_request_uri\nnginx.ingress.kubernetes.io/auth-url: https://$host/oauth2/auth\nnginx.ingress.kubernetes.io/configuration-snippet: |\n  auth_request_set $name_upstream_1 $upstream_cookie_name_1;\n\n  access_by_lua_block {\n    if ngx.var.name_upstream_1 ~= \"\" then\n      ngx.header[\"Set-Cookie\"] = \"name_1=\" .. ngx.var.name_upstream_1 .. ngx.var.auth_cookie:match(\"(; .*)\")\n    end\n  }\n</code></pre> It is recommended to use <code>--session-store-type=redis</code> when expecting large sessions/OIDC tokens (e.g. with MS Azure).</p> <p>You have to substitute name with the actual cookie name you configured via --cookie-name parameter. If you don't set a custom cookie name the variable  should be \"$upstream_cookie__oauth2_proxy_1\" instead of \"$upstream_cookie_name_1\" and the new cookie-name should be \"_oauth2_proxy_1=\" instead of \"name_1=\".</p>"},{"location":"configuration/overview/#configuring-for-use-with-the-traefik-v2-forwardauth-middleware","title":"Configuring for use with the Traefik (v2) <code>ForwardAuth</code> middleware","text":"<p>This option requires <code>--reverse-proxy</code> option to be set.</p>"},{"location":"configuration/overview/#forwardauth-with-401-errors-middleware","title":"ForwardAuth with 401 errors middleware","text":"<p>The Traefik v2 <code>ForwardAuth</code> middleware allows Traefik to authenticate requests via the oauth2-proxy's <code>/oauth2/auth</code> endpoint on every request, which only returns a 202 Accepted response or a 401 Unauthorized response without proxying the whole request through. For example, on Dynamic File (YAML) Configuration:</p> <pre><code>http:\n  routers:\n    a-service:\n      rule: \"Host(`a-service.example.com`)\"\n      service: a-service-backend\n      middlewares:\n        - oauth-errors\n        - oauth-auth\n      tls:\n        certResolver: default\n        domains:\n          - main: \"example.com\"\n            sans:\n              - \"*.example.com\"\n    oauth:\n      rule: \"Host(`a-service.example.com`, `oauth.example.com`) &amp;&amp; PathPrefix(`/oauth2/`)\"\n      middlewares:\n        - auth-headers\n      service: oauth-backend\n      tls:\n        certResolver: default\n        domains:\n          - main: \"example.com\"\n            sans:\n              - \"*.example.com\"\n\n  services:\n    a-service-backend:\n      loadBalancer:\n        servers:\n          - url: http://172.16.0.2:7555\n    oauth-backend:\n      loadBalancer:\n        servers:\n          - url: http://172.16.0.1:4180\n\n  middlewares:\n    auth-headers:\n      headers:\n        sslRedirect: true\n        stsSeconds: 315360000\n        browserXssFilter: true\n        contentTypeNosniff: true\n        forceSTSHeader: true\n        sslHost: example.com\n        stsIncludeSubdomains: true\n        stsPreload: true\n        frameDeny: true\n    oauth-auth:\n      forwardAuth:\n        address: https://oauth.example.com/oauth2/auth\n        trustForwardHeader: true\n    oauth-errors:\n      errors:\n        status:\n          - \"401-403\"\n        service: oauth-backend\n        query: \"/oauth2/sign_in?rd={url}\"\n</code></pre>"},{"location":"configuration/overview/#forwardauth-with-static-upstreams-configuration","title":"ForwardAuth with static upstreams configuration","text":"<p>Redirect to sign_in functionality provided without the use of <code>errors</code> middleware with Traefik v2 <code>ForwardAuth</code> middleware pointing to oauth2-proxy service's <code>/</code> endpoint</p> <p>Following options need to be set on <code>oauth2-proxy</code>: - <code>--upstream=static://202</code>: Configures a static response for authenticated sessions - <code>--reverse-proxy=true</code>: Enables the use of <code>X-Forwarded-*</code> headers to determine redirects correctly</p> <pre><code>http:\n  routers:\n    a-service-route-1:\n      rule: \"Host(`a-service.example.com`, `b-service.example.com`) &amp;&amp; PathPrefix(`/`)\"\n      service: a-service-backend\n      middlewares:\n        - oauth-auth-redirect # redirects all unauthenticated to oauth2 signin\n      tls:\n        certResolver: default\n        domains:\n          - main: \"example.com\"\n            sans:\n              - \"*.example.com\"\n    a-service-route-2:\n      rule: \"Host(`a-service.example.com`) &amp;&amp; PathPrefix(`/no-auto-redirect`)\"\n      service: a-service-backend\n      middlewares:\n        - oauth-auth-wo-redirect # unauthenticated session will return a 401\n      tls:\n        certResolver: default\n        domains:\n          - main: \"example.com\"\n            sans:\n              - \"*.example.com\"\n    services-oauth2-route:\n      rule: \"Host(`a-service.example.com`, `b-service.example.com`) &amp;&amp; PathPrefix(`/oauth2/`)\"\n      middlewares:\n        - auth-headers\n      service: oauth-backend\n      tls:\n        certResolver: default\n        domains:\n          - main: \"example.com\"\n            sans:\n              - \"*.example.com\"\n    oauth2-proxy-route:\n      rule: \"Host(`oauth.example.com`) &amp;&amp; PathPrefix(`/`)\"\n      middlewares:\n        - auth-headers\n      service: oauth-backend\n      tls:\n        certResolver: default\n        domains:\n          - main: \"example.com\"\n            sans:\n              - \"*.example.com\"\n\n  services:\n    a-service-backend:\n      loadBalancer:\n        servers:\n          - url: http://172.16.0.2:7555\n    b-service-backend:\n      loadBalancer:\n        servers:\n          - url: http://172.16.0.3:7555\n    oauth-backend:\n      loadBalancer:\n        servers:\n          - url: http://172.16.0.1:4180\n\n  middlewares:\n    auth-headers:\n      headers:\n        sslRedirect: true\n        stsSeconds: 315360000\n        browserXssFilter: true\n        contentTypeNosniff: true\n        forceSTSHeader: true\n        sslHost: example.com\n        stsIncludeSubdomains: true\n        stsPreload: true\n        frameDeny: true\n    oauth-auth-redirect:\n      forwardAuth:\n        address: https://oauth.example.com/\n        trustForwardHeader: true\n        authResponseHeaders:\n          - X-Auth-Request-Access-Token\n          - Authorization\n    oauth-auth-wo-redirect:\n      forwardAuth:\n        address: https://oauth.example.com/oauth2/auth\n        trustForwardHeader: true\n        authResponseHeaders:\n          - X-Auth-Request-Access-Token\n          - Authorization\n</code></pre> <p>Note</p> <p>If you set up your OAuth2 provider to rotate your client secret, you can use the <code>client-secret-file</code> option to reload the secret when it is updated.</p> <ol> <li> <p>Only these providers support <code>--cookie-refresh</code>: GitLab, Google and OIDC\u00a0\u21a9</p> </li> <li> <p>When using the <code>whitelist-domain</code> option, any domain prefixed with a <code>.</code> or a <code>*.</code> will allow any subdomain of the specified domain as a valid redirect URL. By default, only empty ports are allowed. This translates to allowing the default port of the URLs protocol (80 for HTTP, 443 for HTTPS, etc.) since browsers omit them. To allow only a specific port, add it to the whitelisted domain: <code>example.com:8080</code>. To allow any port, use <code>*</code>: <code>example.com:*</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"configuration/sessions/","title":"Session Storage","text":"<p>Sessions allow a user's authentication to be tracked between multiple HTTP requests to a service.</p> <p>The OAuth2 Proxy uses a Cookie to track user sessions and will store the session data in one of the available session storage backends.</p> <p>At present the available backends are (as passed to <code>--session-store-type</code>): - cookie (default) - redis</p>"},{"location":"configuration/sessions/#cookie-storage","title":"Cookie Storage","text":"<p>The Cookie storage backend is the default backend implementation and has been used in the OAuth2 Proxy historically.</p> <p>With the Cookie storage backend, all session information is stored in client side cookies and transferred with each and every request.</p> <p>The following should be known when using this implementation: - Since all state is stored client side, this storage backend means that the OAuth2 Proxy is completely stateless - Cookies are signed server side to prevent modification client-side - It is mandatory to set a <code>cookie-secret</code> which will ensure data is encrypted within the cookie data. - Since multiple requests can be made concurrently to the OAuth2 Proxy, this session implementation cannot lock sessions and while updating and refreshing sessions, there can be conflicts which force users to re-authenticate</p>"},{"location":"configuration/sessions/#redis-storage","title":"Redis Storage","text":"<p>The Redis Storage backend stores encrypted sessions in redis. Instead of sending all the information back the client for storage, as in the Cookie storage, a ticket is sent back to the user as the cookie value instead.</p> <p>A ticket is composed as the following:</p> <p><code>{CookieName}-{ticketID}.{secret}</code></p> <p>Where:</p> <ul> <li>The <code>CookieName</code> is the OAuth2 cookie name (_oauth2_proxy by default)</li> <li>The <code>ticketID</code> is a 128-bit random number, hex-encoded</li> <li>The <code>secret</code> is a 128-bit random number, base64url encoded (no padding). The secret is unique for every session.</li> <li>The pair of <code>{CookieName}-{ticketID}</code> comprises a ticket handle, and thus, the redis key to which the session is stored. The encoded session is encrypted with the secret and stored in redis via the <code>SETEX</code> command.</li> </ul> <p>Encrypting every session uniquely protects the refresh/access/id tokens stored in the session from disclosure. Additionally, the browser only has to send a short Cookie with every request and not the whole JWT,  which can get quite big.</p> <p>Two settings are used to configure the OAuth2 Proxy cookie lifetime:</p> <pre><code>--cookie-refresh duration   refresh the cookie after this duration; 0 to disable\n--cookie-expire duration    expire timeframe for cookie     168h0m0s\n</code></pre> <p>The \"cookie-expire\" value should be equal to the lifetime of the Refresh-Token that is issued by the OAuth2 authorization server. If it expires earlier and is deleted by the browser, OAuth2 Proxy cannot find the stored Refresh-Tokens in Redis and thus cannot start the refresh flow to get new Access-Tokens. If it is longer, it might be that the old Refresh-Token will be found in Redis but has already expired.</p> <p>The \"cookie-refresh\" value controls when OAuth2 Proxy tries to refresh an Access-Token. If it is set to \"0\", the Access-Token will never be refreshed, even it is already expired and there would be a valid Refresh-Token in the available. If set, OAuth2 Proxy will refresh the Access-Token after this many seconds even if it is still valid. Of course, it will also be refreshed after it has expired, as long as a Refresh Token is available.</p> <p>Caveat: It can happen that the Access-Token is valid for e.g. \"1m\" and a request happens after exactly \"59s\". It would pass OAuth2 Proxy and be forwarded to the backend but is just expired when the backend tries to validate it. This is especially relevant if the backend uses the JWT to make requests to other backends. For this reason, it's advised to set the cookie-refresh a couple of seconds less than the Access-Token lifespan.</p> <p>Recommended settings:</p> <ul> <li>cookie_refresh := Access-Token lifespan - 1m</li> <li>cookie_expire := Refresh-Token lifespan (i.e. Keycloak client_session_idle)</li> </ul>"},{"location":"configuration/sessions/#usage","title":"Usage","text":"<p>When using the redis store, specify <code>--session-store-type=redis</code> as well as the Redis connection URL, via <code>--redis-connection-url=redis://host[:port][/db-number]</code>.</p> <p>You may also configure the store for Redis Sentinel. In this case, you will want to use the <code>--redis-use-sentinel=true</code> flag, as well as configure the flags <code>--redis-sentinel-master-name</code> and <code>--redis-sentinel-connection-urls</code> appropriately.</p> <p>Redis Cluster is available to be the backend store as well. To leverage it, you will need to set the <code>--redis-use-cluster=true</code> flag, and configure the flags <code>--redis-cluster-connection-urls</code> appropriately.</p> <p>Note that flags <code>--redis-use-sentinel=true</code> and <code>--redis-use-cluster=true</code> are mutually exclusive.</p> <p>Note, if Redis timeout option is set to non-zero, the <code>--redis-connection-idle-timeout</code>  must be less than Redis timeout option. For example: if either redis.conf includes  <code>timeout 15</code> or using <code>CONFIG SET timeout 15</code> the <code>--redis-connection-idle-timeout</code> must be at least <code>--redis-connection-idle-timeout=14</code></p>"},{"location":"configuration/tls/","title":"TLS Configuration","text":"<p>There are two recommended configurations: - At OAuth2 Proxy - At Reverse Proxy</p>"},{"location":"configuration/tls/#terminate-tls-at-oauth2-proxy","title":"Terminate TLS at OAuth2 Proxy","text":"<ol> <li> <p>Configure SSL Termination with OAuth2 Proxy by providing a <code>--tls-cert-file=/path/to/cert.pem</code> and <code>--tls-key-file=/path/to/cert.key</code>.</p> <p>The command line to run <code>oauth2-proxy</code> in this configuration would look like this:</p> <pre><code>./oauth2-proxy \\\n    --email-domain=\"yourcompany.com\"  \\\n    --upstream=http://127.0.0.1:8080/ \\\n    --tls-cert-file=/path/to/cert.pem \\\n    --tls-key-file=/path/to/cert.key \\\n    --cookie-secret=... \\\n    --cookie-secure=true \\\n    --provider=... \\\n    --client-id=... \\\n    --client-secret=...\n</code></pre> </li> <li> <p>With this configuration approach the customization of the TLS settings is limited.</p> <p>The minimal acceptable TLS version can be set with <code>--tls-min-version=TLS1.3</code>.  The defaults set <code>TLS1.2</code> as the minimal version.  Regardless of the minimum version configured, <code>TLS1.3</code> is currently always used as the maximal version.</p> <p>TLS server side cipher suites can be specified with <code>--tls-cipher-suite=TLS_RSA_WITH_RC4_128_SHA</code>. If not specified, the defaults from <code>crypto/tls</code> of the currently used <code>go</code> version for building <code>oauth2-proxy</code> will be used. A complete list of valid TLS cipher suite names can be found in <code>crypto/tls</code>.</p> </li> </ol>"},{"location":"configuration/tls/#terminate-tls-at-reverse-proxy-eg-nginx","title":"Terminate TLS at Reverse Proxy, e.g. Nginx","text":"<ol> <li> <p>Configure SSL Termination with Nginx (example config below), Amazon ELB, Google Cloud Platform Load Balancing, or ...</p> <p>Because <code>oauth2-proxy</code> listens on <code>127.0.0.1:4180</code> by default, to listen on all interfaces (needed when using an external load balancer like Amazon ELB or Google Platform Load Balancing) use <code>--http-address=\"0.0.0.0:4180\"</code> or <code>--http-address=\"http://:4180\"</code>.</p> <p>Nginx will listen on port <code>443</code> and handle SSL connections while proxying to <code>oauth2-proxy</code> on port <code>4180</code>. <code>oauth2-proxy</code> will then authenticate requests for an upstream application. The external endpoint for this example would be <code>https://internal.yourcompany.com/</code>.</p> <p>An example Nginx config follows. Note the use of <code>Strict-Transport-Security</code> header to pin requests to SSL via HSTS:</p> <pre><code>server {\n    listen 443 default ssl;\n    server_name internal.yourcompany.com;\n    ssl_certificate /path/to/cert.pem;\n    ssl_certificate_key /path/to/cert.key;\n    add_header Strict-Transport-Security max-age=2592000;\n\n    location / {\n        proxy_pass http://127.0.0.1:4180;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_connect_timeout 1;\n        proxy_send_timeout 30;\n        proxy_read_timeout 30;\n    }\n}\n</code></pre> </li> <li> <p>The command line to run <code>oauth2-proxy</code> in this configuration would look like this:</p> <pre><code>./oauth2-proxy \\\n   --email-domain=\"yourcompany.com\"  \\\n   --upstream=http://127.0.0.1:8080/ \\\n   --cookie-secret=... \\\n   --cookie-secure=true \\\n   --provider=... \\\n   --reverse-proxy=true \\\n   --client-id=... \\\n   --client-secret=...\n</code></pre> </li> </ol>"},{"location":"configuration/providers/","title":"Index","text":"<p>You will need to register an OAuth application with a Provider (Google, GitHub or another provider), and configure it  with Redirect URI(s) for the domain you intend to run <code>oauth2-proxy</code> on.</p> <p>Valid providers are :</p> <ul> <li>Google default</li> <li>Azure</li> <li>ADFS</li> <li>Facebook</li> <li>GitHub</li> <li>Gitea</li> <li>Keycloak/Keycloak OIDC</li> <li>GitLab</li> <li>LinkedIn</li> <li>Microsoft Azure AD</li> <li>OpenID Connect</li> <li>login.gov</li> <li>Nextcloud</li> <li>DigitalOcean</li> <li>Bitbucket</li> </ul> <p>The provider can be selected using the <code>provider</code> configuration value.</p> <p>Please note that not all providers support all claims. The <code>preferred_username</code> claim is currently only supported by the  OpenID Connect provider.</p>"},{"location":"configuration/providers/#email-authentication","title":"Email Authentication","text":"<p>To authorize a specific email-domain use <code>--email-domain=yourcompany.com</code>. To authorize individual email addresses use  <code>--authenticated-emails-file=/path/to/file</code> with one email per line. To authorize all email addresses use <code>--email-domain=*</code>.</p>"},{"location":"configuration/providers/#adding-a-new-provider","title":"Adding a new Provider","text":"<p>Follow the examples in the <code>providers</code> package to define a new <code>Provider</code> instance. Add a new <code>case</code> to <code>providers.New()</code> to allow <code>oauth2-proxy</code> to use the new <code>Provider</code>.</p>"},{"location":"configuration/providers/adfs/","title":"ADFS","text":"<ol> <li>Open the ADFS administration console on your Windows Server and add a new Application Group</li> <li>Provide a name for the integration, select Server Application from the Standalone applications section and click Next</li> <li>Follow the wizard to get the client-id, client-secret and configure the application credentials</li> <li>Configure the proxy with</li> </ol> <pre><code>   --provider=adfs\n   --client-id=&lt;application ID from step 3&gt;\n   --client-secret=&lt;value from step 3&gt;\n</code></pre> <p>Note: When using the ADFS Auth provider with nginx and the cookie session store you may find the cookie is too large and  doesn't get passed through correctly. Increasing the proxy_buffer_size in nginx or implementing the  redis session storage should resolve this.</p>"},{"location":"configuration/providers/azure/","title":"Azure","text":"<ol> <li>Add an application: go to https://portal.azure.com, choose Azure Active Directory, select    App registrations and then click on New registration.</li> <li>Pick a name, check the supported account type(single-tenant, multi-tenant, etc). In the Redirect URI section create a new    Web platform entry for each app that you want to protect by the oauth2 proxy(e.g.    https://internal.yourcompanycom/oauth2/callback). Click Register.</li> <li>Next we need to add group read permissions for the app registration, on the API Permissions page of the app, click on    Add a permission, select Microsoft Graph, then select Application permissions, then click on Group and select    Group.Read.All. Hit Add permissions and then on Grant admin consent (you might need an admin to do this).    IMPORTANT: Even if this permission is listed with \"Admin consent required=No\" the consent might actually     be required, due to AAD policies you won't be able to see. If you get a \"Need admin approval\" during login,     most likely this is what you're missing!</li> <li>Next, if you are planning to use v2.0 Azure Auth endpoint, go to the Manifest page and set <code>\"accessTokenAcceptedVersion\": 2</code>    in the App registration manifest file.</li> <li>On the Certificates &amp; secrets page of the app, add a new client secret and note down the value after hitting Add.</li> <li>Configure the proxy with:</li> <li>for V1 Azure Auth endpoint (Azure Active Directory Endpoints - https://login.microsoftonline.com/common/oauth2/authorize)</li> </ol> <pre><code>   --provider=azure\n   --client-id=&lt;application ID from step 3&gt;\n   --client-secret=&lt;value from step 5&gt;\n   --azure-tenant={tenant-id}\n   --oidc-issuer-url=https://sts.windows.net/{tenant-id}/\n</code></pre> <ul> <li>for V2 Azure Auth endpoint (Microsoft Identity Platform Endpoints - https://login.microsoftonline.com/common/oauth2/v2.0/authorize) <pre><code>   --provider=azure\n   --client-id=&lt;application ID from step 3&gt;\n   --client-secret=&lt;value from step 5&gt;\n   --azure-tenant={tenant-id}\n   --oidc-issuer-url=https://login.microsoftonline.com/{tenant-id}/v2.0\n</code></pre></li> </ul> <p>Notes: - When using v2.0 Azure Auth endpoint (<code>https://login.microsoftonline.com/{tenant-id}/v2.0</code>) as <code>--oidc_issuer_url</code>, in conjunction   with <code>--resource</code> flag, be sure to append <code>/.default</code> at the end of the resource name. See   https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-permissions-and-consent#the-default-scope for more details. - When using the Azure Auth provider with nginx and the cookie session store you may find the cookie is too large and doesn't   get passed through correctly. Increasing the proxy_buffer_size in nginx or implementing the    redis session storage should resolve this.</p>"},{"location":"configuration/providers/azure_ad/","title":"Azure AD","text":"<p>For adding an application to the Microsoft Azure AD follow these steps to add an application.</p> <p>Take note of your <code>TenantId</code> if applicable for your situation. The <code>TenantId</code> can be used to override the default  <code>common</code> authorization server with a tenant specific server.</p>"},{"location":"configuration/providers/bitbucket/","title":"Bitbucket","text":"<ol> <li>Add a new OAuth consumer<ul> <li>In \"Callback URL\" use <code>https://&lt;oauth2-proxy&gt;/oauth2/callback</code>, substituting <code>&lt;oauth2-proxy&gt;</code> with the actual    hostname that oauth2-proxy is running on.</li> <li>In Permissions section select:<ul> <li>Account -&gt; Email</li> <li>Team membership -&gt; Read</li> <li>Repositories -&gt; Read</li> </ul> </li> </ul> </li> <li>Note the Client ID and Client Secret.</li> </ol> <p>To use the provider, pass the following options:</p> <pre><code>   --provider=bitbucket\n   --client-id=&lt;Client ID&gt;\n   --client-secret=&lt;Client Secret&gt;\n</code></pre> <p>The default configuration allows everyone with Bitbucket account to authenticate. To restrict the access to the team  members use additional configuration option: <code>--bitbucket-team=&lt;Team name&gt;</code>. To restrict the access to only these users  who have access to one selected repository use <code>--bitbucket-repository=&lt;Repository name&gt;</code>.</p>"},{"location":"configuration/providers/digitalocean/","title":"DigitalOcean","text":"<ol> <li>Create a new OAuth application<ul> <li>You can fill in the name, homepage, and description however you wish.</li> <li>In the \"Application callback URL\" field, enter: <code>https://oauth-proxy/oauth2/callback</code>, substituting <code>oauth2-proxy</code>    with the actual hostname that oauth2-proxy is running on. The URL must match oauth2-proxy's configured redirect URL.</li> </ul> </li> <li>Note the Client ID and Client Secret.</li> </ol> <p>To use the provider, pass the following options:</p> <pre><code>   --provider=digitalocean\n   --client-id=&lt;Client ID&gt;\n   --client-secret=&lt;Client Secret&gt;\n</code></pre> <p>Alternatively, set the equivalent options in the config file. The redirect URL defaults to  <code>https://&lt;requested host header&gt;/oauth2/callback</code>. If you need to change it, you can use the <code>--redirect-url</code> command-line option.</p>"},{"location":"configuration/providers/facebook/","title":"Facebook","text":"<ol> <li>Create a new FB App from https://developers.facebook.com/</li> <li>Under FB Login, set your Valid OAuth redirect URIs to <code>https://internal.yourcompany.com/oauth2/callback</code></li> </ol>"},{"location":"configuration/providers/gitea/","title":"Gitea","text":"<ol> <li>Create a new application: <code>https://&lt; your gitea host &gt;/user/settings/applications</code></li> <li>Under <code>Redirect URI</code> enter the correct URL i.e. <code>https://&lt;proxied host&gt;/oauth2/callback</code></li> <li>Note the Client ID and Client Secret.</li> <li>Pass the following options to the proxy:</li> </ol> <pre><code>    --provider=\"github\"\n    --redirect-url=\"https://&lt;proxied host&gt;/oauth2/callback\"\n    --provider-display-name=\"Gitea\"\n    --client-id=\"&lt; client_id as generated by Gitea &gt;\"\n    --client-secret=\"&lt; client_secret as generated by Gitea &gt;\"\n    --login-url=\"https://&lt; your gitea host &gt;/login/oauth/authorize\"\n    --redeem-url=\"https://&lt; your gitea host &gt;/login/oauth/access_token\"\n    --validate-url=\"https://&lt; your gitea host &gt;/api/v1/user/emails\"\n</code></pre>"},{"location":"configuration/providers/github/","title":"GitHub","text":"<ol> <li>Create a new project: https://github.com/settings/developers</li> <li>Under <code>Authorization callback URL</code> enter the correct url ie <code>https://internal.yourcompany.com/oauth2/callback</code></li> </ol> <p>The GitHub auth provider supports two additional ways to restrict authentication to either organization and optional  team level access, or to collaborators of a repository. Restricting by these options is normally accompanied with <code>--email-domain=*</code>. Additionally, all the organizations and teams a user belongs to are set as part of the <code>X-Forwarded-Groups</code> header. e.g. <code>org1:team1,org1:team2,org2:team1</code></p> <p>NOTE: When <code>--github-user</code> is set, the specified users are allowed to log in even if they do not belong to the specified  org and team or collaborators.</p> <p>To restrict by organization only, include the following flag:</p> <pre><code>    --github-org=\"\"  # restrict logins to members of this organisation\n</code></pre> <p>To restrict within an organization to specific teams, include the following flag in addition to <code>-github-org</code>:</p> <pre><code>    --github-team=\"\"  # restrict logins to members of any of these teams (slug), separated by a comma\n</code></pre> <p>If you would rather restrict access to collaborators of a repository, those users must either have push access to a  public repository or any access to a private repository:</p> <pre><code>    --github-repo=\"\"  # restrict logins to collaborators of this repository formatted as orgname/repo\n</code></pre> <p>If you'd like to allow access to users with read only access to a public repository you will need to provide a  token for a user that has write access to the repository. The token must be  created with at least the <code>public_repo</code> scope:</p> <pre><code>    --github-token=\"\"  # the token to use when verifying repository collaborators\n</code></pre> <p>To allow a user to log in with their username even if they do not belong to the specified org and team or collaborators,  separated by a comma</p> <pre><code>    --github-user=\"\" #allow logins by username, separated by a comma\n</code></pre> <p>If you are using GitHub enterprise, make sure you set the following to the appropriate url:</p> <pre><code>    --login-url=\"http(s)://&lt;enterprise github host&gt;/login/oauth/authorize\"\n    --redeem-url=\"http(s)://&lt;enterprise github host&gt;/login/oauth/access_token\"\n    --validate-url=\"http(s)://&lt;enterprise github host&gt;/api/v3\"\n</code></pre>"},{"location":"configuration/providers/gitlab/","title":"GitLab","text":"<p>This auth provider has been tested against Gitlab version 12.X. Due to Gitlab API changes, it may not work for version  prior to 12.X (see 994).</p> <p>Whether you are using GitLab.com or self-hosting GitLab, follow  these steps to add an application. Make sure to enable at  least the <code>openid</code>, <code>profile</code> and <code>email</code> scopes, and set the redirect url to your application url e.g.  https://myapp.com/oauth2/callback.</p> <p>If you need projects filtering, add the extra <code>read_api</code> scope to your application.</p> <p>The following config should be set to ensure that the oauth will work properly. To get a cookie secret follow  these steps</p> <pre><code>    --provider=\"gitlab\"\n    --redirect-url=\"https://myapp.com/oauth2/callback\" // Should be the same as the redirect url for the application in gitlab\n    --client-id=GITLAB_CLIENT_ID\n    --client-secret=GITLAB_CLIENT_SECRET\n    --cookie-secret=COOKIE_SECRET\n</code></pre> <p>Restricting by group membership is possible with the following option:</p> <pre><code>    --gitlab-group=\"mygroup,myothergroup\"  # restrict logins to members of any of these groups (slug), separated by a comma\n</code></pre> <p>If you are using self-hosted GitLab, make sure you set the following to the appropriate URL:</p> <pre><code>    --oidc-issuer-url=\"&lt;your gitlab url&gt;\"\n</code></pre> <p>If your self-hosted GitLab is on a subdirectory (e.g. domain.tld/gitlab), as opposed to its own subdomain  (e.g. gitlab.domain.tld), you may need to add a redirect from domain.tld/oauth pointing at e.g. domain.tld/gitlab/oauth.</p>"},{"location":"configuration/providers/google/","title":"Google","text":"<p>For Google, the registration steps are:</p> <ol> <li>Create a new project: https://console.developers.google.com/project</li> <li>Choose the new project from the top right project dropdown (only if another project is selected)</li> <li>In the project Dashboard center pane, choose \"APIs &amp; Services\"</li> <li>In the left Nav pane, choose \"Credentials\"</li> <li>In the center pane, choose \"OAuth consent screen\" tab. Fill in \"Product name shown to users\" and hit save.</li> <li>In the center pane, choose \"Credentials\" tab.<ul> <li>Open the \"New credentials\" drop down</li> <li>Choose \"OAuth client ID\"</li> <li>Choose \"Web application\"</li> <li>Application name is freeform, choose something appropriate</li> <li>Authorized JavaScript origins is your domain ex: <code>https://internal.yourcompany.com</code></li> <li>Authorized redirect URIs is the location of oauth2/callback ex: <code>https://internal.yourcompany.com/oauth2/callback</code></li> <li>Choose \"Create\"</li> </ul> </li> <li>Take note of the Client ID and Client Secret</li> </ol> <p>It's recommended to refresh sessions on a short interval (1h) with <code>cookie-refresh</code> setting which validates that the  account is still authorized.</p>"},{"location":"configuration/providers/google/#restrict-auth-to-specific-google-groups-on-your-domain-optional","title":"Restrict auth to specific Google groups on your domain. (optional)","text":"<ol> <li>Create a service account and configure it      to use Application Default Credentials / Workload Identity / Workload Identity Federation (recommended) or,      alternatively download the JSON.</li> <li>Make note of the Client ID for a future step.</li> <li>Under \"APIs &amp; Auth\", choose APIs.</li> <li>Click on Admin SDK and then Enable API.</li> <li> <p>Follow the steps on https://developers.google.com/workspace/guides/create-credentials#optional_set_up_domain-wide_delegation_for_a_service_account      and give the client id from step 2 the following oauth scopes:</p> <pre><code>https://www.googleapis.com/auth/admin.directory.group.readonly\nhttps://www.googleapis.com/auth/admin.directory.user.readonly\n</code></pre> </li> <li> <p>Follow the steps on https://support.google.com/a/answer/60757 to enable Admin API access.</p> </li> <li>Create or choose an existing administrative email address on the Gmail domain to assign to the <code>google-admin-email</code>      flag. This email will be impersonated by this client to make calls to the Admin SDK. See the note on the link from      step 5 for the reason why.</li> <li>Create or choose an existing email group and set that email to the <code>google-group</code> flag. You can pass multiple instances      of this flag with different groups and the user will be checked against all the provided groups.</li> </ol> <p>(Only if using a JSON file (see step 1)) 9.  Lock down the permissions on the json file downloaded from step 1 so only oauth2-proxy is able to read the file and      set the path to the file in the <code>google-service-account-json</code> flag. 10. Restart oauth2-proxy.</p> <p>Note: The user is checked against the group members list on initial authentication and every time the token is  refreshed ( about once an hour ).</p>"},{"location":"configuration/providers/google/#using-application-default-credentials-adc-workload-identity-workload-identity-federation-recommended","title":"Using Application Default Credentials (ADC) / Workload Identity / Workload Identity Federation (recommended)","text":"<p>oauth2-proxy can make use of Application Default Credentials. When deployed within GCP, this means that it can automatically use the service account attached to the resource. When deployed to GKE, ADC can be leveraged through a feature called Workload Identity. Follow Google's guide to set up Workload Identity.</p> <p>When deployed outside of GCP, Workload Identity Federation might be an option.</p>"},{"location":"configuration/providers/keycloak/","title":"Keycloak","text":"<p>Note</p> <p>This is the legacy provider for Keycloak, use Keycloak OIDC Auth Provider if possible.</p> <ol> <li>Create new client in your Keycloak realm with Access Type 'confidential' and Valid Redirect URIs 'https://internal.yourcompany.com/oauth2/callback'</li> <li>Take note of the Secret in the credential tab of the client</li> <li>Create a mapper with Mapper Type 'Group Membership' and Token Claim Name 'groups'.</li> </ol> <p>Make sure you set the following to the appropriate url:</p> <pre><code>    --provider=keycloak\n    --client-id=&lt;client you have created&gt;\n    --client-secret=&lt;your client's secret&gt;\n    --login-url=\"http(s)://&lt;keycloak host&gt;/auth/realms/&lt;your realm&gt;/protocol/openid-connect/auth\"\n    --redeem-url=\"http(s)://&lt;keycloak host&gt;/auth/realms/&lt;your realm&gt;/protocol/openid-connect/token\"\n    --profile-url=\"http(s)://&lt;keycloak host&gt;/auth/realms/&lt;your realm&gt;/protocol/openid-connect/userinfo\"\n    --validate-url=\"http(s)://&lt;keycloak host&gt;/auth/realms/&lt;your realm&gt;/protocol/openid-connect/userinfo\"\n    --keycloak-group=&lt;first_allowed_user_group&gt;\n    --keycloak-group=&lt;second_allowed_user_group&gt;\n</code></pre> <p>For group based authorization, the optional <code>--keycloak-group</code> (legacy) or <code>--allowed-group</code> (global standard) flags can be used to specify which groups to limit access to.</p> <p>If these are unset but a <code>groups</code> mapper is set up above in step (3), the provider will still populate the <code>X-Forwarded-Groups</code> header to your upstream server with the <code>groups</code> data in the Keycloak userinfo endpoint response.</p> <p>The group management in keycloak is using a tree. If you create a group named admin in keycloak you should define the 'keycloak-group' value to /admin.</p>"},{"location":"configuration/providers/keycloak_oidc/","title":"Keycloak OIDC","text":"<pre><code>    --provider=keycloak-oidc\n    --client-id=&lt;your client's id&gt;\n    --client-secret=&lt;your client's secret&gt;\n    --redirect-url=https://internal.yourcompany.com/oauth2/callback\n    --oidc-issuer-url=https://&lt;keycloak host&gt;/realms/&lt;your realm&gt; // For Keycloak versions &lt;17: --oidc-issuer-url=https://&lt;keycloak host&gt;/auth/realms/&lt;your realm&gt;\n    --email-domain=&lt;yourcompany.com&gt; // Validate email domain for users, see option documentation\n    --allowed-role=&lt;realm role name&gt; // Optional, required realm role\n    --allowed-role=&lt;client id&gt;:&lt;client role name&gt; // Optional, required client role\n    --allowed-group=&lt;/group name&gt; // Optional, requires group client scope\n    --code-challenge-method=S256 // PKCE\n</code></pre> <p>Note</p> <p>Keycloak has updated its admin console and as of version 19.0.0, the new admin console is enabled by default. The  legacy admin console has been announced for removal with the release of version 21.0.0.</p> <p>Keycloak legacy admin console</p> <ol> <li>Create new client in your Keycloak realm with Access Type 'confidential', Client protocol  'openid-connect'      and Valid Redirect URIs 'https://internal.yourcompany.com/oauth2/callback'</li> <li>Take note of the Secret in the credential tab of the client</li> <li>Create a mapper with Mapper Type 'Group Membership' and Token Claim Name 'groups'.</li> <li>Create a mapper with Mapper Type 'Audience' and Included Client Audience and Included Custom Audience set      to your client name.</li> </ol> <p>Keycloak new admin console (default as of v19.0.0)</p> <p>The following example shows how to create a simple OIDC client using the new Keycloak admin2 console. However, for best  practices, it is recommended to consult the Keycloak documentation.</p> <p>The OIDC client must be configured with an audience mapper to include the client's name in the <code>aud</code> claim of the JWT token. The <code>aud</code> claim specifies the intended recipient of the token, and OAuth2 Proxy expects a match against the values of  either <code>--client-id</code> or <code>--oidc-extra-audience</code>.</p> <p>In Keycloak, claims are added to JWT tokens through the use of mappers at either the realm level using \"client scopes\" or  through \"dedicated\" client mappers.</p> <p>Creating the client</p> <ol> <li>Create a new OIDC client in your Keycloak realm by navigating to: Clients -&gt; Create client</li> <li>Client Type 'OpenID Connect'</li> <li>Client ID <code>&lt;your client's id&gt;</code>, please complete the remaining fields as appropriate and click Next.<ul> <li>Client authentication 'On'</li> <li>Authentication flow<ul> <li>Standard flow  'selected'</li> <li>Direct access grants 'deselect'<ul> <li>Save the configuration.</li> </ul> </li> </ul> </li> <li>Settings / Access settings:<ul> <li>Valid redirect URIs <code>https://internal.yourcompany.com/oauth2/callback</code><ul> <li>Save the configuration.</li> </ul> </li> </ul> </li> <li>Under the Credentials tab you will now be able to locate <code>&lt;your client's secret&gt;</code>.</li> </ul> </li> <li>Configure a dedicated audience mapper for your client by navigating to Clients -&gt; \\** -&gt; Client scopes**. <li>Access the dedicated mappers pane by clicking \\&lt;your client's id&gt;-dedicated, located under Assigned client scope. (It should have a description of \"Dedicated scope and mappers for this client\")<ul> <li>Click Configure a new mapper and select Audience<ul> <li>Name 'aud-mapper-\\&lt;your client's id&gt;'</li> <li>Included Client Audience select <code>&lt;your client's id&gt;</code> from the dropdown.<ul> <li>OAuth2 proxy can be set up to pass both the access and ID JWT tokens to your upstream services.   If you require additional audience entries, you can use the Included Custom Audience field in addition    to the \"Included Client Audience\" dropdown. Note that the \"aud\" claim of a JWT token should be limited and    only specify its intended recipients.</li> </ul> </li> <li>Add to ID token 'On'</li> <li>Add to access token 'On' - #1916<ul> <li>Save the configuration.</li> </ul> </li> </ul> </li> </ul> </li> <li>Any subsequent dedicated client mappers can be defined by clicking Dedicated scopes -&gt; Add mapper -&gt;    By configuration -&gt; Select mapper</li> <p>You should now be able to create a test user in Keycloak and get access to the OAuth2 Proxy instance, make sure to set  an email address matching <code>&lt;yourcompany.com&gt;</code> and select Email verified.</p> <p>Authorization</p> <p>OAuth2 Proxy will perform authorization by requiring a valid user, this authorization can be extended to take into  account a user's membership in Keycloak <code>groups</code>, <code>realm roles</code>, and <code>client roles</code> using the keycloak-oidc provider options  <code>--allowed-role</code> or <code>--allowed-group</code></p> <p>Roles</p> <p>A standard Keycloak installation comes with the required mappers for realm roles and client roles through the  pre-defined client scope \"roles\". This ensures that any roles assigned to a user are included in the <code>JWT</code> tokens when  using an OIDC client that has the \"Full scope allowed\" feature activated, the feature is enabled by default.</p> <p>Creating a realm role * Navigate to Realm roles -&gt; Create role     * Role name, <code>&lt;realm role name&gt;</code> -&gt; save</p> <p>Creating a client role * Navigate to Clients -&gt; <code>&lt;your client's id&gt;</code> -&gt; Roles -&gt; Create role     * Role name, <code>&lt;client role name&gt;</code> -&gt; save</p> <p>Assign a role to a user</p> <p>Users -&gt; Username -&gt; Role mapping -&gt; Assign role -&gt; filter by roles or clients and select -&gt; Assign.</p> <p>Keycloak \"realm roles\" can be authorized using the <code>--allowed-role=&lt;realm role name&gt;</code> option, while \"client roles\" can be  evaluated using <code>--allowed-role=&lt;your client's id&gt;:&lt;client role name&gt;</code>.</p> <p>You may limit the realm roles included in the JWT tokens for any given client by navigating to: Clients -&gt; <code>&lt;your client's id&gt;</code> -&gt; Client scopes -&gt;  _\\-dedicated_ -&gt; Scope Disabling Full scope allowed activates the Assign role option, allowing you to select which roles, if assigned  to a user, will be included in the user's JWT tokens. This can be useful when a user has many associated roles, and you  want to reduce the size and impact of the JWT token. <p>Groups</p> <p>You may also do authorization on group memberships by using the OAuth2 Proxy option <code>--allowed-group</code>.  We will only do a brief description of creating the required client scope groups and refer you to read the Keycloak  documentation.</p> <p>To summarize, the steps required to authorize Keycloak group membership with OAuth2 Proxy are as follows:</p> <ul> <li>Create a new Client Scope with the name groups in Keycloak.<ul> <li>Include a mapper of type Group Membership.</li> <li>Set the \"Token Claim Name\" to groups or customize by matching it to the <code>--oidc-groups-claim</code> option of OAuth2 Proxy.</li> <li>If the \"Full group path\" option is selected, you need to include a \"/\" separator in the group names defined in the    <code>--allowed-group</code> option of OAuth2 Proxy. Example: \"/groupname\" or \"/groupname/child_group\".</li> </ul> </li> </ul> <p>After creating the Client Scope named groups you will need to attach it to your client. Clients -&gt; <code>&lt;your client's id&gt;</code> -&gt; Client scopes -&gt; Add client scope -&gt; Select groups and choose Optional  and you should now have a client that maps group memberships into the JWT tokens so that Oauth2 Proxy may evaluate them.</p> <p>Create a group by navigating to Groups -&gt; Create group and add your test user as a member.</p> <p>The OAuth2 Proxy option <code>--allowed-group=/groupname</code> will now allow you to filter on group membership</p> <p>Keycloak also has the option of attaching roles to groups, please refer to the Keycloak documentation for more information.</p> <p>Tip</p> <p>To check if roles or groups are added to JWT tokens, you can preview a users token in the Keycloak console by following  these steps: Clients -&gt; <code>&lt;your client's id&gt;</code> -&gt; Client scopes -&gt; Evaluate. Select a realm user and optional scope parameters such as groups, and generate the JSON representation of an access  or id token to examine its contents.</p>"},{"location":"configuration/providers/linkedin/","title":"LinkedIn","text":"<p>For LinkedIn, the registration steps are:</p> <ol> <li>Create a new project: https://www.linkedin.com/secure/developer</li> <li>In the OAuth User Agreement section:<ul> <li>In default scope, select r_basicprofile and r_emailaddress.</li> <li>In \"OAuth 2.0 Redirect URLs\", enter <code>https://internal.yourcompany.com/oauth2/callback</code></li> </ul> </li> <li>Fill in the remaining required fields and Save.</li> <li>Take note of the Consumer Key / API Key and Consumer Secret / Secret Key</li> </ol>"},{"location":"configuration/providers/login_gov/","title":"Login.gov","text":"<p>login.gov is an OIDC provider for the US Government. If you are a US Government agency, you can contact the login.gov team through the contact information that you can find on https://login.gov/developers/ and work with them to understand how to get login.gov accounts for integration/test and production access.</p> <p>A developer guide is available here: https://developers.login.gov/, though this proxy handles everything but the data you need to create to register your application in the login.gov dashboard.</p> <p>As a demo, we will assume that you are running your application that you want to secure locally on http://localhost:3000/, that you will be starting your proxy up on http://localhost:4180/, and that you have an agency integration account for testing.</p> <p>First, register your application in the dashboard.  The important bits are: * Identity protocol:  make this <code>Openid connect</code> * Issuer:  do what they say for OpenID Connect.  We will refer to this string as <code>${LOGINGOV_ISSUER}</code>. * Public key:  This is a self-signed certificate in .pem format generated from a 2048-bit RSA private key.   A quick way to do this is    <code>openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 3650 -nodes -subj '/C=US/ST=Washington/L=DC/O=GSA/OU=18F/CN=localhost'</code>.   The contents of the <code>key.pem</code> shall be referred to as <code>${OAUTH2_PROXY_JWT_KEY}</code>. * Return to App URL:  Make this be <code>http://localhost:4180/</code> * Redirect URIs:  Make this be <code>http://localhost:4180/oauth2/callback</code>. * Attribute Bundle:  Make sure that email is selected.</p> <p>Now start the proxy up with the following options: <pre><code>./oauth2-proxy -provider login.gov \\\n  -client-id=${LOGINGOV_ISSUER} \\\n  -redirect-url=http://localhost:4180/oauth2/callback \\\n  -oidc-issuer-url=https://idp.int.identitysandbox.gov/ \\\n  -cookie-secure=false \\\n  -email-domain=gsa.gov \\\n  -upstream=http://localhost:3000/ \\\n  -cookie-secret=somerandomstring12341234567890AB \\\n  -cookie-domain=localhost \\\n  -skip-provider-button=true \\\n  -pubjwk-url=https://idp.int.identitysandbox.gov/api/openid_connect/certs \\\n  -profile-url=https://idp.int.identitysandbox.gov/api/openid_connect/userinfo \\\n  -jwt-key=\"${OAUTH2_PROXY_JWT_KEY}\"\n</code></pre> You can also set all these options with environment variables, for use in cloud/docker environments. One tricky thing that you may encounter is that some cloud environments will pass in environment variables in a docker env-file, which does not allow multiline variables like a PEM file. If you encounter this, then you can create a <code>jwt_signing_key.pem</code> file in the top level directory of the repo which contains the key in PEM format and then do your docker build. The docker build process will copy that file into your image which you can then access by setting the <code>OAUTH2_PROXY_JWT_KEY_FILE=/etc/ssl/private/jwt_signing_key.pem</code> environment variable, or by setting <code>--jwt-key-file=/etc/ssl/private/jwt_signing_key.pem</code> on the commandline.</p> <p>Once it is running, you should be able to go to <code>http://localhost:4180/</code> in your browser, get authenticated by the login.gov integration server, and then get proxied on to your application running on <code>http://localhost:3000/</code>.  In a real deployment, you would secure your application with a firewall or something so that it was only accessible from the proxy, and you would use real hostnames everywhere.</p>"},{"location":"configuration/providers/login_gov/#skip-oidc-discovery","title":"Skip OIDC discovery","text":"<p>Some providers do not support OIDC discovery via their issuer URL, so oauth2-proxy cannot simply grab the authorization,  token and jwks URI endpoints from the provider's metadata.</p> <p>In this case, you can set the <code>--skip-oidc-discovery</code> option, and supply those required endpoints manually:</p> <pre><code>    -provider oidc\n    -client-id oauth2-proxy\n    -client-secret proxy\n    -redirect-url http://127.0.0.1:4180/oauth2/callback\n    -oidc-issuer-url http://127.0.0.1:5556\n    -skip-oidc-discovery\n    -login-url http://127.0.0.1:5556/authorize\n    -redeem-url http://127.0.0.1:5556/token\n    -oidc-jwks-url http://127.0.0.1:5556/keys\n    -cookie-secure=false\n    -email-domain example.com\n</code></pre>"},{"location":"configuration/providers/nextcloud/","title":"Nextcloud","text":"<p>The Nextcloud provider allows you to authenticate against users in your Nextcloud instance.</p> <p>When you are using the Nextcloud provider, you must specify the urls via configuration, environment variable, or command line argument. Depending on whether your Nextcloud instance is using pretty urls your urls may be of the form <code>/index.php/apps/oauth2/*</code> or <code>/apps/oauth2/*</code>.</p> <p>Refer to the OAuth2 documentation to set up the client id and client secret. Your \"Redirection URI\" will be <code>https://internalapp.yourcompany.com/oauth2/callback</code>.</p> <pre><code>    -provider nextcloud\n    -client-id &lt;from nextcloud admin&gt;\n    -client-secret &lt;from nextcloud admin&gt;\n    -login-url=\"&lt;your nextcloud url&gt;/index.php/apps/oauth2/authorize\"\n    -redeem-url=\"&lt;your nextcloud url&gt;/index.php/apps/oauth2/api/v1/token\"\n    -validate-url=\"&lt;your nextcloud url&gt;/ocs/v2.php/cloud/user?format=json\"\n</code></pre> <p>Note: in all cases the validate-url will not have the <code>index.php</code>.</p>"},{"location":"configuration/providers/openid_connect/","title":"OpenID Connect","text":"<p>OpenID Connect is a spec for OAUTH 2.0 + identity that is implemented by many major providers and several open source projects.</p> <p>This provider was originally built against CoreOS Dex, and we will use it as an example. The OpenID Connect Provider (OIDC) can also be used to connect to other Identity Providers such as Okta, an example can be found below.</p>"},{"location":"configuration/providers/openid_connect/#dex","title":"Dex","text":"<p>To configure the OIDC provider for Dex, perform the following steps:</p> <ol> <li> <p>Download Dex:</p> <pre><code>go get github.com/dexidp/dex\n</code></pre> </li> </ol> <p>See the getting started guide for more details.</p> <ol> <li> <p>Setup oauth2-proxy with the correct provider and using the default ports and callbacks. Add a configuration block to     the <code>staticClients</code> section of <code>examples/config-dev.yaml</code>:</p> <pre><code>- id: oauth2-proxy\nredirectURIs:\n- 'http://127.0.0.1:4180/oauth2/callback'\nname: 'oauth2-proxy'\nsecret: proxy\n</code></pre> </li> <li> <p>Launch Dex: from <code>$GOPATH/github.com/dexidp/dex</code>, run:</p> <pre><code>bin/dex serve examples/config-dev.yaml\n</code></pre> </li> <li> <p>In a second terminal, run the oauth2-proxy with the following args:</p> <pre><code>--provider oidc\n--provider-display-name \"My OIDC Provider\"\n--client-id oauth2-proxy\n--client-secret proxy\n--redirect-url http://127.0.0.1:4180/oauth2/callback\n--oidc-issuer-url http://127.0.0.1:5556/dex\n--cookie-secure=false\n--cookie-secret=secret\n--email-domain kilgore.trout\n</code></pre> </li> </ol> <p>To serve the current working directory as a website under the <code>/static</code> endpoint, add:</p> <pre><code>```shell\n--upstream file://$PWD/#/static/\n```\n</code></pre> <ol> <li>Test the setup by visiting http://127.0.0.1:4180 or http://127.0.0.1:4180/static .</li> </ol> <p>See also our local testing environment for a self-contained example using Docker and etcd as storage for Dex.</p>"},{"location":"configuration/providers/openid_connect/#okta","title":"Okta","text":"<p>To configure the OIDC provider for Okta, perform the following steps:</p> <ol> <li>Log in to Okta using an administrative account. It is suggested you try this in preview first, <code>example.oktapreview.com</code></li> <li>(OPTIONAL) If you want to configure authorization scopes and claims to be passed on to multiple applications,    you may wish to configure an authorization server for each application. Otherwise, the provided <code>default</code> will work.</li> <li>Navigate to Security then select API</li> <li>Click Add Authorization Server, if this option is not available you may require an additional license for a custom       authorization server.</li> <li>Fill out the Name with something to describe the application you are protecting. e.g. 'Example App'.</li> <li>For Audience, pick the URL of the application you wish to protect: https://example.corp.com</li> <li>Fill out a Description</li> <li>Add any Access Policies you wish to configure to limit application access.</li> <li>The default settings will work for other options.      See Okta documentation for more information on Authorization Servers</li> <li>Navigate to Applications then select Add Application.</li> <li>Select Web for the Platform setting.</li> <li>Select OpenID Connect and click Create</li> <li>Pick an Application Name such as <code>Example App</code>.</li> <li>Set the Login redirect URI to <code>https://example.corp.com</code>.</li> <li>Under General set the Allowed grant types to <code>Authorization Code</code> and <code>Refresh Token</code>.</li> <li>Leave the rest as default, taking note of the <code>Client ID</code> and <code>Client Secret</code>.</li> <li>Under Assignments select the users or groups you wish to access your application.</li> <li> <p>Create a configuration file like the following:</p> <pre><code>provider = \"oidc\"\nredirect_url = \"https://example.corp.com/oauth2/callback\"\noidc_issuer_url = \"https://corp.okta.com/oauth2/abCd1234\"\nupstreams = [\n    \"https://example.corp.com\"\n]\nemail_domains = [\n    \"corp.com\"\n]\nclient_id = \"XXXXX\"\nclient_secret = \"YYYYY\"\npass_access_token = true\ncookie_secret = \"ZZZZZ\"\nskip_provider_button = true\n</code></pre> </li> </ol> <p>The <code>oidc_issuer_url</code> is based on URL from your Authorization Server's Issuer field in step 2, or simply  https://corp.okta.com. The <code>client_id</code> and <code>client_secret</code> are configured in the application settings. Generate a unique <code>cookie_secret</code> to encrypt the cookie.</p> <p>Then you can start the oauth2-proxy with <code>./oauth2-proxy --config /etc/example.cfg</code></p>"},{"location":"configuration/providers/openid_connect/#okta-localhost","title":"Okta - localhost","text":"<ol> <li>Signup for developer account: https://developer.okta.com/signup/</li> <li>Create New <code>Web</code> Application: https://${your-okta-domain}/dev/console/apps/new</li> <li>Example Application Settings for localhost:<ul> <li>Name: My Web App</li> <li>Base URIs: http://localhost:4180/</li> <li>Login redirect URIs: http://localhost:4180/oauth2/callback</li> <li>Logout redirect URIs: http://localhost:4180/</li> <li>Group assignments: <code>Everyone</code></li> <li>Grant type allowed: <code>Authorization Code</code> and <code>Refresh Token</code></li> </ul> </li> <li>Make note of the <code>Client ID</code> and <code>Client secret</code>, they are needed in a future step</li> <li>Make note of the default Authorization Server Issuer URI from: https://${your-okta-domain}/admin/oauth2/as</li> <li>Example config file <code>/etc/localhost.cfg</code> <pre><code>provider = \"oidc\"\nredirect_url = \"http://localhost:4180/oauth2/callback\"\noidc_issuer_url = \"https://$\\{your-okta-domain\\}/oauth2/default\"\nupstreams = [\n    \"http://0.0.0.0:8080\"\n]\nemail_domains = [\n    \"*\"\n]\nclient_id = \"XXX\"\nclient_secret = \"YYY\"\npass_access_token = true\ncookie_secret = \"ZZZ\"\ncookie_secure = false\nskip_provider_button = true\n# Note: use the following for testing within a container\n# http_address = \"0.0.0.0:4180\"\n</code></pre></li> <li>Then you can start the oauth2-proxy with <code>./oauth2-proxy --config /etc/localhost.cfg</code></li> </ol>"},{"location":"features/endpoints/","title":"Endpoints","text":"<p>OAuth2 Proxy responds directly to the following endpoints. All other endpoints will be proxied upstream when authenticated. The <code>/oauth2</code> prefix can be changed with the <code>--proxy-prefix</code> config variable.</p> <ul> <li>/robots.txt - returns a 200 OK response that disallows all User-agents from all paths; see robotstxt.org for more info</li> <li>/ping - returns a 200 OK response, which is intended for use with health checks</li> <li>/ready - returns a 200 OK response if all the underlying connections (e.g., Redis store) are connected</li> <li>/metrics - Metrics endpoint for Prometheus to scrape, serve on the address specified by <code>--metrics-address</code>, disabled by default</li> <li>/oauth2/sign_in - the login page, which also doubles as a sign-out page (it clears cookies)</li> <li>/oauth2/sign_out - this URL is used to clear the session cookie</li> <li>/oauth2/start - a URL that will redirect to start the OAuth cycle</li> <li>/oauth2/callback - the URL used at the end of the OAuth cycle. The oauth app will be configured with this as the callback url.</li> <li>/oauth2/userinfo - the URL is used to return user's email from the session in JSON format.</li> <li>/oauth2/auth - only returns a 202 Accepted response or a 401 Unauthorized response; for use with the Nginx <code>auth_request</code> directive</li> <li>/oauth2/static/* - stylesheets and other dependencies used in the sign_in and error pages</li> </ul>"},{"location":"features/endpoints/#sign-out","title":"Sign out","text":"<p>To sign the user out, redirect them to <code>/oauth2/sign_out</code>. This endpoint only removes oauth2-proxy's own cookies, i.e. the user is still logged in with the authentication provider and may automatically re-login when accessing the application again. You will also need to redirect the user to the authentication provider's sign-out page afterward using the <code>rd</code> query parameter, i.e. redirect the user to something like (notice the url-encoding!):</p> <pre><code>/oauth2/sign_out?rd=https%3A%2F%2Fmy-oidc-provider.example.com%2Fsign_out_page\n</code></pre> <p>Alternatively, include the redirect URL in the <code>X-Auth-Request-Redirect</code> header:</p> <pre><code>GET /oauth2/sign_out HTTP/1.1\nX-Auth-Request-Redirect: https://my-oidc-provider/sign_out_page\n...\n</code></pre> <p>(The \"sign_out_page\" should be the <code>end_session_endpoint</code> from the metadata if your OIDC provider supports Session Management and Discovery.)</p> <p>BEWARE that the domain you want to redirect to (<code>my-oidc-provider.example.com</code> in the example) must be added to the <code>--whitelist-domain</code> configuration option otherwise the redirect will be ignored. Make sure to include the actual domain and port (if needed) and not the URL (e.g \"localhost:8081\" instead of \"http://localhost:8081\").</p>"},{"location":"features/endpoints/#auth","title":"Auth","text":"<p>This endpoint returns 202 Accepted response or a 401 Unauthorized response.</p> <p>It can be configured using the following query parameters: - <code>allowed_groups</code>: comma separated list of allowed groups - <code>allowed_email_domains</code>: comma separated list of allowed email domains - <code>allowed_emails</code>: comma separated list of allowed emails</p>"}]}